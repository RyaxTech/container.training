<!DOCTYPE html>
<html>
  <head>
    <title>Kubernetes  Stockage, Configuration, Secrets et Concepts Avancés  </title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" href="workshop.css">
  </head>
  <body>
    <!--
    <div style="position: absolute; left: 20%; right: 20%; top: 30%;">
      <h1 style="font-size: 3em;">Loading ...</h1>
      The slides should show up here. If they don't, it might be
      because you are accessing this file directly from your filesystem.
      It needs to be served from a web server. You can try this:
      <pre>
        docker-compose up -d
        open http://localhost:8888/workshop.html # on MacOS
        xdg-open http://localhost:8888/workshop.html # on Linux
      </pre>
      Once the slides are loaded, this notice disappears when you
      go full screen (e.g. by hitting "f").
    </div>
    -->
    <textarea id="source">class: title, self-paced

Kubernetes <br/>Stockage, Configuration, Secrets et Concepts Avancés <br/>

.nav[*Self-paced version*]

.debug[
```
 M intro-fullday.yml.html
 M intro-selfpaced.yml.html
 M kube-fullday.yml.html
 M kube-halfday.yml.html
 M kube-jour1.yml.html
 M kube-jour2.yml.html
 M kube-jour3.yml.html
 M kube-selfpaced.yml.html
 M swarm-fullday.yml.html
 M swarm-halfday.yml.html
 M swarm-selfpaced.yml.html
 M swarm-video.yml.html
?? .directory
?? common/.directory
?? intro/.directory
?? kube/.directory
?? kube/recapj2_fr.md
?? swarm/.directory

```

These slides have been built from commit: 41af34e


[common/title_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//common/title_fr.md)]
---

class: title, in-person

Kubernetes <br/>Stockage, Configuration, Secrets et Concepts Avancés <br/><br/></br>


.debug[[common/title_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//common/title_fr.md)]
---

name: toc-chapter-1

## Chapter 1

- [Serverless](#toc-serverless)

.debug[(auto-generated TOC)]
---
name: toc-chapter-2

## Chapter 2

- [Introduction aux volumes](#toc-introduction-aux-volumes)

- [Introduction de PersistentVolumes et PersistentVolumeClaims](#toc-introduction-de-persistentvolumes-et-persistentvolumeclaims)

- [Provisionnement dynamique des volumes persistants](#toc-provisionnement-dynamique-des-volumes-persistants)

- [Rook orchestration de stockage distribué](#toc-rook-orchestration-de-stockage-distribu)

.debug[(auto-generated TOC)]
---
name: toc-chapter-3

## Chapter 3

- [Recap Jour 2](#toc-recap-jour-)

.debug[(auto-generated TOC)]
---
name: toc-chapter-4

## Chapter 4

- [Découplage de configuration avec un ConfigMap](#toc-dcouplage-de-configuration-avec-un-configmap)

- [Introduction des secrets](#toc-introduction-des-secrets)

.debug[(auto-generated TOC)]
---
name: toc-chapter-5

## Chapter 5

- [Monitoring avec Prometheus et Grafana](#toc-monitoring-avec-prometheus-et-grafana)

.debug[(auto-generated TOC)]
---
name: toc-chapter-6

## Chapter 6

- [StatefulSets](#toc-statefulsets)

.debug[(auto-generated TOC)]
---
name: toc-chapter-7

## Chapter 7

- [Autoscaling avec Kubernetes](#toc-autoscaling-avec-kubernetes)

- [CI/CD with Spinnaker](#toc-cicd-with-spinnaker)

- [Déploiement de Jupiter sur Kubernetes](#toc-dploiement-de-jupiter-sur-kubernetes)

- [Scheduling avancée avec Kubernetes](#toc-scheduling-avance-avec-kubernetes)

- [Big Data analytics sur Kubernetes](#toc-big-data-analytics-sur-kubernetes)

.debug[(auto-generated TOC)]



.debug[[common/toc.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//common/toc.md)]
---

class: pic

.interstitial[![Image separating from the next chapter](https://gallant-turing-d0d520.netlify.com/containers/Container-Ship-Freighter-Navigation-Elbe-Romance-1782991.jpg)]

---

name: toc-serverless
class: title

Serverless

.nav[
[Section précédente](#toc-)
|
[Retour table des matières](#toc-chapter-1)
|
[Section suivante](#toc-introduction-aux-volumes)
]

.debug[(automatically generated title slide)]

---

# Serverless

.debug[[kube/serverless_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/serverless_fr.md)]
---
class: pic

![apigateway](images/serverless_apigateway.png)

.debug[[kube/serverless_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/serverless_fr.md)]
---

## Exemple d'une fonction serverless
```python
import json, logging, os, time, uuid
import boto3
dynamodb = boto3.resource('dynamodb')

def create(event, context):
    data = json.loads(event['body'])
    table = dynamodb.Table(os.environ['DYNAMODB_TABLE'])

    item = {
        'id': str(uuid.uuid1()),
        'text': data['text'],
        'createdAt': int(time.time() * 1000),
    }

    table.put_item(Item=item)
    return {
        "statusCode": 200,
        "body": json.dumps(item)
    }
```
.debug[[kube/serverless_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/serverless_fr.md)]
---

## Que faire de ça ?

1) l'uploader sur une plateforme de serverless

2) configurer l'API Gateway de cette plateforme pour que la fonction soit appelé lors d'un evenement choisi.


.debug[[kube/serverless_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/serverless_fr.md)]
---

## Les avantages du serverless

- Pas d'administration (pour l'utilisateur)

- Auto-scaling

- Pay-per-use

- déployer plus souvent et plus rapidement

- Applications multi-language

- Le développeur n'a pas à se soucier de la scalabilité de son code

.debug[[kube/serverless_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/serverless_fr.md)]
---

## Les défauts du serverless

- Le développeur n'a pas à se soucier de la scalabilité de son code
    - la difficulté de parallélisation est dans la base de donnée sous jacente (ex: dynamoDB)

- Plus d'éléments indépendants à gérer

- Une erreur peut être propager à travers plusieurs fonctions avant de causer des problèmes

- Programmer des fonctions *"purs"* peut être difficile

- Les sysadmins changent du code (en mettant à jour par exemple python), sans connaitre le code qui l'utilise => possibilité de bugs!


.debug[[kube/serverless_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/serverless_fr.md)]
---

## Les Use Cases

- Gestion de contenu (ex: genérer des aperçus d'images)
- Traiter des évenements venant de SaaS (ex: quand un msg "pizza" reçu sur slack, commander un pizza)
- Auto-scaling des sites webs et des APIs
- Hybrid-cloud Applications
- Data Pipeline, principalement du Extract-Transform-Load
- Notifications
- Real time update
- Client access : un fonction pour valider un token
- Live data migration
- CI/CD


.debug[[kube/serverless_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/serverless_fr.md)]
---

## Exemple de use case


- Exemple avec un site web de livraison mensuel de box de chocolats:

    - le frontend est gérer par un service wordpress
    - les formulaires sont géré par un service externe (ex: formstack)
    - le paiement est géré par un service externe (ex: stripe, paypal)
    - la base de donnée client est géré par un service externe (ex: google sheet, firebase)
    - la gestion des stocks est faites via un service externe (ex: Odoo, SAP)
    - quand un nouvel utilisateur s'enregistre, ses informations sont rajouté dans la base client
    - quand un nouveau client est entrée dans la base, la commande est ajouter dans le gestionnaire de stock
    - quand un nouveau mail apparet dans la base client, des mails marketing sont envoyé (pour acheter des *super* boites, avec plus de chocolats)
    - ...

.debug[[kube/serverless_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/serverless_fr.md)]
---

## Le serverless permet un découplage

- Une application coder avec du serverless permet de découpler les services, des données, de l'intéligence.

- Le developpeur a juste à connécter les bons services entre eux.

- Voir "API economy".



.debug[[kube/serverless_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/serverless_fr.md)]
---

class: pic
![Landscape](images/CloudNativeLandscape_Serverless_latest.png)

.debug[[kube/serverless_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/serverless_fr.md)]
---

class: pic

.interstitial[![Image separating from the next chapter](https://gallant-turing-d0d520.netlify.com/containers/ShippingContainerSFBay.jpg)]

---

name: toc-introduction-aux-volumes
class: title

Introduction aux volumes

.nav[
[Section précédente](#toc-serverless)
|
[Retour table des matières](#toc-chapter-2)
|
[Section suivante](#toc-introduction-de-persistentvolumes-et-persistentvolumeclaims)
]

.debug[(automatically generated title slide)]

---
# Introduction aux volumes

- Les volumes de Kubernetes sont une composante d'un pod et sont donc définis dans la spécification de pods, tout comme les conteneurs.

- Ils ne sont pas un objet Kubernetes autonome et ne peuvent pas être créés ou supprimés par eux-mêmes.

- Un volume est disponible pour tous les conteneurs du pod, mais il doit être monté dans chaque conteneur qui doit y accéder.

- Dans chaque conteneur, vous pouvez monter le volume à n'importe quel emplacement de son système de fichiers.

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Les volumes par un exemple

- Conteneurs qui n'ont pas de stockage commune

- Conteneurs qui partageant 2 volumes montés dans des chemins de montage différents

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

class: pic

![haha seulement blague](images/volumes1.png)

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

class: pic

![haha seulement blague](images/volume2.png)

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---


## Remarques

- Les schemas ont été repris du livre de Marko Luksa "Kubernetes in Action"

- Le volume /var/logs n'est pas monté dans le conteneur ContentAgent.

- Le conteneur ne peut pas accéder à ses fichiers, même si le conteneur et le volume font partie du même conteneur.

- Il ne suffit pas de définir un volume dans le pod; vous devez également définir un VolumeMount dans la spécification du conteneur, si vous voulez que le conteneur puisse y accéder.

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Types de volume

- Une grande variété de types de volumes est disponible. Plusieurs sont génériques, tandis que d'autres sont spécifiques aux technologies de stockage utilisées en dessous.

* `emptyDir`: un répertoire vide simple utilisé pour stocker des données transitoires.
* `hostPath`: Utilisé pour monter les répertoires du système de fichiers du noeud worker dans le pod.
* `gitRepo`: Un volume initialisé en vérifiant le contenu d'un dépôt Git.
* `nfs`: un partage NFS monté dans le pod.
* `gcePersistentDisk`, `awsElasticBlockStore`, `azureDisk`: Utilisé pour monter le stockage spécifique au fournisseur de cloud.
* `cinder`, `cephfs`, ...: Utilisé pour monter d'autres types de stockage réseau.
* `configMap`, `secret`, `downwardAPI`: Types spéciaux de volumes utilisés pour exposer certaines ressources et informations de cluster Kubernetes au pod.
* `persistentVolumeClaim`: un moyen d'utiliser un stockage persistant pré-provisionné ou dynamiquement.

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Remarque

- Un seul pod peut utiliser plusieurs volumes de types différents en même temps

- Chacun des conteneurs du pod peut avoir le volume monté ou non.

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Exemple d'un pod utilisant le volume gitrepo

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

.exercise[
  ```bash
apiVersion: v1
kind: Pod
metadata:
  name: gitrepo-volume-pod
spec:
  containers:
  - image: nginx:alpine
    name: web-server
    volumeMounts:
    - name: html
      mountPath: /usr/share/nginx/html
      readOnly: true
    ports:
    - containerPort: 80
      protocol: TCP
  volumes:
  - name: html
    gitRepo:
      repository: https://github.com/luksa/kubia-website-example.git
      revision: master
      directory: .   
  ```
]

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Découplage des pods de la technologie de stockage sous-jacente

- Le cas ci-dessus est contre l'idée de base de Kubernetes, qui vise à cacher l'infrastructure réelle de l'application et de son développeur.

- Lorsqu'un développeur a besoin d'une certaine quantité de stockage persistant pour son application, il doit le demander à Kubernetes.

- De la même manière qu'ils demandent du CPU, de la mémoire et d'autres ressources lors de la création d'un pod.

- L'administrateur système peut configurer le cluster afin qu'il puisse donner aux applications ce qu'elles demandent.

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

class: pic

.interstitial[![Image separating from the next chapter](https://gallant-turing-d0d520.netlify.com/containers/aerial-view-of-containers.jpg)]

---

name: toc-introduction-de-persistentvolumes-et-persistentvolumeclaims
class: title

Introduction de PersistentVolumes et PersistentVolumeClaims

.nav[
[Section précédente](#toc-introduction-aux-volumes)
|
[Retour table des matières](#toc-chapter-2)
|
[Section suivante](#toc-provisionnement-dynamique-des-volumes-persistants)
]

.debug[(automatically generated title slide)]

---

# Introduction de PersistentVolumes et PersistentVolumeClaims

- Au lieu que le développeur ajoute un volume spécifique à son pod, c'est l'administrateur du cluster qui configure le stockage sous-jacent, puis l'enregistre dans
Kubernetes en créant une ressource PersistentVolume via le serveur de l'API Kubernetes.

- Lors de la création de PersistentVolume, l'administrateur spécifie sa taille et les modes d'accès
qu'il supporte.

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Introduction de PersistentVolumes et PersistentVolumeClaims

- Lorsqu'un utilisateur de cluster doit utiliser un stockage persistant dans l'un de ses pods, il crée d'abord un manifeste PersistentVolumeClaim, en spécifiant la taille minimale et le mode d'accès qu'ils exigent.

- L'utilisateur soumet ensuite le manifeste PersistentVolumeClaim au serveur de l'API Kubernetes, et Kubernetes trouve le PersistentVolume approprié et lie au Volume Claim.

- Le PersistentVolumeClaim peut alors être utilisé comme l'un des volumes à l'intérieur d'un pod. Les autres utilisateurs ne peuvent pas utiliser le même PersistentVolume jusqu'à ce qu'il ait été libéré en supprimant
le PersistentVolumeClaim lié.

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Exemple de PersistentVolumes et PersistentVolumeClaims

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

class: pic

![haha seulement blague](images/volumes3.png)

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## PersistentVolumes et Namespaces

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

class: pic

![haha seulement blague](images/Volume4.png)

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Durée de vie de PersistentVolume et PersistentVolumeClaims

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

class: pic

![haha seulement blague](images/Volume5.png)

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

class: pic

.interstitial[![Image separating from the next chapter](https://gallant-turing-d0d520.netlify.com/containers/blue-containers.jpg)]

---

name: toc-provisionnement-dynamique-des-volumes-persistants
class: title

Provisionnement dynamique des volumes persistants

.nav[
[Section précédente](#toc-introduction-de-persistentvolumes-et-persistentvolumeclaims)
|
[Retour table des matières](#toc-chapter-2)
|
[Section suivante](#toc-rook-orchestration-de-stockage-distribu)
]

.debug[(automatically generated title slide)]

---
# Provisionnement dynamique des volumes persistants

- Les schemas précédents ont été repris du livre de Marko Luksa "Kubernetes in Action"

- Nous avons vu comment l'utilisation de PersistentVolumes et PersistentVolumeClaims facilite l'obtention d'un stockage persistant sans que le développeur n'ait à gérer le stockage réel utilisée en dessous.

- Mais cela nécessite toujours un administrateur de cluster pour provisionner le stockage réel à l'avance.

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Provisionnement dynamique des volumes persistants

- Heureusement, Kubernetes peut également effectuer ce travail automatiquement grâce au provisionnement dynamique de PersistentVolumes.

- L'administrateur du cluster, au lieu de créer PersistentVolumes, peut déployer un provisionneur PersistentVolume et définir un ou plusieurs objets StorageClass pour permettre aux utilisateurs de choisir le type de PersistentVolume souhaité.

- Les utilisateurs peuvent se référer à StorageClass dans leur PersistanceVolumeClaims et le provisionneur en tiendra compte lors de l'approvisionnement du stockage persistant.

- Le schema suivant a été repris du livre de Marko Luksa "Kubernetes in Action" 

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Provisionnement dynamique des volumes persistants

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

class: pic

![haha seulement blague](images/volume6.png)

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

class: pic

.interstitial[![Image separating from the next chapter](https://gallant-turing-d0d520.netlify.com/containers/chinook-helicopter-container.jpg)]

---

name: toc-rook-orchestration-de-stockage-distribu
class: title

Rook orchestration de stockage distribué

.nav[
[Section précédente](#toc-provisionnement-dynamique-des-volumes-persistants)
|
[Retour table des matières](#toc-chapter-2)
|
[Section suivante](#toc-recap-jour-)
]

.debug[(automatically generated title slide)]

---

# Rook orchestration de stockage distribué

- Rook est un orchestrateur open source pour les systèmes de stockage distribués.

- Rook transforme le logiciel de stockage distribué en un service de stockage auto-géré, auto-scalable et auto-guérisant.

- Il le fait en automatisant le déploiement, l'amorçage, la configuration, l'approvisionnement, la mise à l'échelle, la mise à niveau, la migration, la reprise après sinistre, la surveillance et la gestion des ressources.

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Rook orchestration de stockage distribué

- Rook se concentre d'abord sur l'orchestration de Ceph sur Kubernetes. Ceph est un système de stockage distribué qui permet le stockage de fichiers, de blocs et d'objets et qui est déployé dans des clusters de production à grande échelle.

- Rook est hébergé par la Cloud Native Computing Foundation (CNCF) en tant que projet de niveau initial.

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Exemple de provisionnement dynamique de PersistentVolumes à l'aide de Rook

.exercise[
  ```bash
   git clone https://github.com/rook/rook.git
   cd rook/cluster/examples/kubernetes/ceph
   kubectl create -f operator.yaml
   kubectl create -f cluster.yaml
  ```
- vérifiez pour voir si tout fonctionne comme prévu
  ```bash
   kubectl get pods -n rook-ceph
  ```

]

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Exemple de provisionnement dynamique de PersistentVolumes à l'aide de Rook

- Le stockage 'block' vous permet de monter le stockage dans un seul pod.

- Voyons comment construire une application web simple et multi-niveaux sur Kubernetes en utilisant des volumes persistants activés par Rook.

--

- Avant que Rook puisse démarrer le provisionnement, une classe StorageClass et son pool de stockage doivent être créés.

- Ceci est nécessaire pour que Kubernetes puisse interopérer avec Rook pour provisionner des volumes persistants.

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---
## Exemple de provisionnement dynamique de PersistentVolumes à l'aide de Rook

<!--   kubectl create -f pool.yaml -->
.exercise[
- Créez le pool et le storage class:
  ```bash
  kubectl create -f storageclass.yaml
  ```
]
- Consommez le stockage avec l'échantillon wordpress
- Nous créons un exemple d'application pour consommer le stockage en 'block' provisionné par Rook avec les applications classiques wordpress et mysql.
- Ces deux applications utiliseront les volumes 'block' provisionnés par Rook.

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Exemple de provisionnement dynamique de PersistentVolumes à l'aide de Rook


.exercise[
- Démarrez mysql et wordpress depuis le dossier cluster/examples/kubernetes:
  ```bash
  kubectl create -f mysql.yaml
  kubectl create -f wordpress.yaml
  ```
- Ces deux applications créent un volume en 'block' et le montent dans leur pod respectif. Vous pouvez voir les 'volume claims' de Kubernetes en exécutant les opérations suivantes:

  ```bash
  kubectl get pvc
  ```
- Vous devriez voir quelque chose comme ça:
```bash
NAME             STATUS    VOLUME        CAPACITY   ACCESSMODES   AGE
mysql-pv-claim   Bound     pvc-954459ee   20Gi       RWO           1m
wp-pv-claim      Bound     pvc-39e459ee   20Gi       RWO           1m
```
]
.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Exemple de provisionnement dynamique de PersistentVolumes à l'aide de Rook

.exercise[
- Une fois que les pods wordpress et mysql sont dans l'état Running, récupérez l'adresse IP du cluster de l'application wordpress et entrez-la dans votre navigateur avec le port:

 ```bash
 kubectl get svc wordpress
 ```
]
Vous devriez voir l'application wordpress en cours d'exécution.

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Lancez un autre exemple de provisionnement dynamique

.exercise[

- Récupérez le fichier:
  ```bash
  wget https://raw.githubusercontent.com/zonca/jupyterhub-deploy-kubernetes-jetstream/master/storage_rook/alpine-rook.yaml
  ```

- Modifiez-le pour qu'il corresponde aux spécifications de votre cluster (notre `storageClassName` est `"rook-ceph-block"`) et exécutez-le en utilisant:
  ```bash
  kubectl create -f alpine-rook.yaml
  ```

]

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Lancez un autre exemple de provisionnement dynamique (suite)

- C'est un petit pod avec Alpine Linux qui crée un volume de 2 Go à partir de Rook et le monte sur /data.

- Cela crée un Pod avec Alpine Linux qui demande qu'un Persistent Volume Claim soit montée sous /data.

- Le PersistentVolumeClaim spécifiait le type de stockage et sa taille.

- Une fois le Pod créé, il demande au PersistentVolumeClaim de demander à Rook de préparer un volume persistant qui sera ensuite monté dans le pod.

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Lancez un autre exemple de provisionnement dynamique (suite)

- Nous pouvons vérifier que les Volumes Persistants sont créés et associés au pod, vérifiez:

.exercice[
  ```bash
  kubectl get pv
  kubectl get pvc
  kubectl get logs alpine
  ```
- Obtenez un shell dans le pod avec:
  ```bash
  kubectl exec -it alpine /bin/sh
  ```
- Créer des fichiers dans `/data/`.
- Quitter le terminal
- Maintenant supprimez le pod. Est-il encore possible daccéder ces données ? Si oui, comment ?
]

<!-----
## Lancez un autre exemple de provisionnement dynamique (suite)

.exercice[
- Comment aurions-nous pu récupérer les données dans le dernier cas?
- Changeons alpine-rook.yaml en `kind:deployment`, écrivez quelques fichiers et tuez à nouveau le pod pour voir ce qui se passe.
]-->



.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

class: pic

.interstitial[![Image separating from the next chapter](https://gallant-turing-d0d520.netlify.com/containers/container-cranes.jpg)]

---

name: toc-recap-jour-
class: title

Recap Jour 2

.nav[
[Section précédente](#toc-rook-orchestration-de-stockage-distribu)
|
[Retour table des matières](#toc-chapter-3)
|
[Section suivante](#toc-dcouplage-de-configuration-avec-un-configmap)
]

.debug[(automatically generated title slide)]

---

# Recap Jour 2


L'équipe marketing à determiner que la vA du serveurweb était la meilleure.

Vous aller donc lancer un service qui exposera un **pod**.

Cependant, ils veulent aussi que vous rajoutiez un dossier `bonus` dans /tmp/ qui contiendra un fichier `bonus.txt`. Ce fichier aura juste le texte "bonus" dedans.

Lors de la réunion vous sentez que ce fichier va surement changer souvent... Vous décidez qu'au lieu de changer l'image docker, vous aller monter un volume persitant qui vous permettera de changer rapidement le contenu de ce dossier.

- Conseil: ne foncez pas tête baisser. Faites un plan, puis éxecutez le.

- Conseil 2: la slide suivante contient de l'aide... A vous de voir...

.debug[[kube/recapj2_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/recapj2_fr.md)]
---

## Aide

- Repartez de https://raw.githubusercontent.com/zonca/jupyterhub-deploy-kubernetes-jetstream/master/storage_rook/alpine-rook.yaml

- l'image du serveur A s'appelle `127.0.0.1:32092/serverweb:vA`

- Pour écrire le fichier bonus, connéctez-vous au pod:
  ```bash
kubectl exec -ti alpine -- sh
  ```




.debug[[kube/recapj2_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/recapj2_fr.md)]
---

class: pic

.interstitial[![Image separating from the next chapter](https://gallant-turing-d0d520.netlify.com/containers/container-housing.jpg)]

---

name: toc-dcouplage-de-configuration-avec-un-configmap
class: title

Découplage de configuration avec un ConfigMap

.nav[
[Section précédente](#toc-recap-jour-)
|
[Retour table des matières](#toc-chapter-4)
|
[Section suivante](#toc-introduction-des-secrets)
]

.debug[(automatically generated title slide)]

---
# Découplage de configuration avec un ConfigMap

- Le but de la configuration d'une application est de garder les options de configuration qui varient d'un environnement à l'autre, ou de changer fréquemment, séparément de la source de l'application
code.

- Si vous considérez un descripteur de pod comme un code source pour votre application (il définit comment composer les composants individuels dans un système fonctionnel), il est clair que vous devez supprimer la configuration de la description du pod.

.debug[[kube/configs_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/configs_fr.md)]
---

## Introduction de ConfigMap

- Kubernetes permet de séparer les options de configuration en un objet distinct appelé ConfigMap, qui est une map contenant des paires clé / valeur avec des valeurs allant de
des littéraux courts aux fichiers de configuration complets.

- Une application n'a pas besoin de lire directement le ConfigMap ou même de savoir qu'il existe. Le contenu de la map est plutôt transmis aux conteneurs comme environnement
variables ou en tant que fichiers dans un volume.

.debug[[kube/configs_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/configs_fr.md)]
---

## Introduction de ConfigMap

- Vous pouvez définir les entrées de la map en transmettant des littéraux à la commande kubectl ou vous pouvez créer ConfigMap à partir de fichiers stockés sur votre disque.

.exercise[
- Pour créer une nouvelle entrée:
  ```bash
  kubectl create configmap fortune-config --from-literal=sleep-interval=25
  ```
- Pour regarder les valeurs d'un ConfigMap:
  ```bash
  kubectl describe configmap fortune-config
  ```
]

- REMARQUE Les clés ConfigMap doivent être un sous-domaine DNS valide (elles ne peuvent contenir que des caractères alphanumériques, des tirets, des traits de soulignement et des points). Ils peuvent éventuellement commencer par un point.

.debug[[kube/configs_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/configs_fr.md)]
---

## Explication de Configmaps dans un exemple

- Exécutez l'exemple décrit ici: https://kubernetes.io/docs/tutorials/configuration/configure-redis-using-configmap/

Attention ! Votre version de Kubernetes ne supporte pas encore qu'il est une URL dans l'option --from-file !


- Pour aller plus loin: https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/

.debug[[kube/configs_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/configs_fr.md)]
---

class: pic

.interstitial[![Image separating from the next chapter](https://gallant-turing-d0d520.netlify.com/containers/containers-by-the-water.jpg)]

---

name: toc-introduction-des-secrets
class: title

Introduction des secrets

.nav[
[Section précédente](#toc-dcouplage-de-configuration-avec-un-configmap)
|
[Retour table des matières](#toc-chapter-4)
|
[Section suivante](#toc-monitoring-avec-prometheus-et-grafana)
]

.debug[(automatically generated title slide)]

---

# Introduction des secrets

- Kubernetes fournit un objet séparé appelé Secret. Les secrets ressemblent beaucoup à ConfigMaps

- Ce sont aussi des maps qui contiennent des paires clé-valeur. Ils peuvent être utilisés de la même manière qu'un ConfigMap.

- Vous pouvez passer des entrées secrètes au conteneur en tant que variables d'environnement

- Expose les entrées secrètes en tant que fichiers dans un volume

.debug[[kube/configs_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/configs_fr.md)]
---

## Introduction des secrets

- Kubernetes aide à garder vos secrets en toute sécurité en s'assurant que chaque secret est seulement distribué
aux nœuds qui exécutent les pods qui ont besoin d'accéder au secret.

- De plus, sur les nœuds eux-mêmes, les Secrets sont toujours stockés en mémoire et jamais écrits dans le stockage physique,
ce qui nécessiterait de nettoyer les disques après avoir supprimé les secrets d'eux.

.debug[[kube/configs_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/configs_fr.md)]
---
## Introduction des secrets

- Sur le nœud maître proprement dit, etcd stocke les secrets sous forme cryptée, ce qui rend le système beaucoup plus sécurisé. Pour cette raison, il est impératif que vous choisissez correctement quand utiliser un Secret ou un ConfigMap. Choisir entre eux est simple:

 * Utilisez un fichier ConfigMap pour stocker des données de configuration non sensibles et simples.
--

 * Utilisez un secret pour stocker toutes les données sensibles et doivent être conservées sous clé. Si un fichier de configuration contient des données sensibles mais aussi non sensibles, vous
devrez stocker le fichier dans un secret.

.debug[[kube/configs_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/configs_fr.md)]
---

## Exercices utilisant des secrets

- Quelques exercices initiaux utilisant Secrets peuvent être trouvés ici: https://kubernetes.io/docs/concepts/configuration/secret/

.debug[[kube/configs_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/configs_fr.md)]
---

class: pic

.interstitial[![Image separating from the next chapter](https://gallant-turing-d0d520.netlify.com/containers/distillery-containers.jpg)]

---

name: toc-monitoring-avec-prometheus-et-grafana
class: title

Monitoring avec Prometheus et Grafana

.nav[
[Section précédente](#toc-introduction-des-secrets)
|
[Retour table des matières](#toc-chapter-5)
|
[Section suivante](#toc-statefulsets)
]

.debug[(automatically generated title slide)]

---
# Monitoring avec Prometheus et Grafana

- Prometheus, pour le monitoring

- Grafana, pour afficher les métriques et jouer avec.

.debug[[kube/monitoring_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/monitoring_fr.md)]
---

## Kube Prometheus

Kube Prometheus est un dépot git qui permet d'installer une stack de monitoring Prometheus+Grafana pour kubernetes.
Il configure aussi Grafana pour intégrer des graphiques utiles.

.exercise[
  ```bash
git clone https://github.com/coreos/prometheus-operator.git

cd prometheus-operator/contrib/kube-prometheus/

kubectl create -f manifests/
  ```
]

.debug[[kube/monitoring_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/monitoring_fr.md)]
---

## Grafana

.exercise[
- Ouvrez le service grafana à l'exterieur, connectez-vous y avec votre navigateur web

- Si vous avez besoin  de vous logguer : admin/admin

- Cliquez sur "Home" tout en haut de l'écran, choisissez le dashboard *Pods*.

- Quel est l'utilisation mémoire du pod registery ?

- Quel est le coût des pods du daemonset de prometheus ?

]


.debug[[kube/monitoring_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/monitoring_fr.md)]
---

## reset

  ```bash
kubectl delete -f manifests/
  ```


.debug[[kube/monitoring_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/monitoring_fr.md)]
---

class: pic

.interstitial[![Image separating from the next chapter](https://gallant-turing-d0d520.netlify.com/containers/lots-of-containers.jpg)]

---

name: toc-statefulsets
class: title

StatefulSets

.nav[
[Section précédente](#toc-monitoring-avec-prometheus-et-grafana)
|
[Retour table des matières](#toc-chapter-6)
|
[Section suivante](#toc-autoscaling-avec-kubernetes)
]

.debug[(automatically generated title slide)]

---

# StatefulSets

- Un StatefulSet permet d'avoir un ensemble de pod qui ont un nom et un état stable.

- Quelle différence avec un ReplicaSet (deployment) ?

  - un ReplicaSet c'est comme gérer un troupeau de vache : on se fiche du nom des vaches, on veut juste savoir combien il y en a. Si une vache est malade, on la remplace.

  - un StatefulSet c'est comme gérer un groupe d'animaux de compagnie : on leur donne des noms et on ne peut pas les remplacer facilement. Si jamais on veut en remplacer un il va falloir en trouver un avec le même nom et le même apparence.


.debug[[kube/statefulsets.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/statefulsets.md)]
---
## Repliquer des pods Stateful


![replicasets](images/replicasets.png)

A cause du système de template des ReplicaSet, on ne peut donner qu'un seul et unique nom pour le PersistentVolumeClaim.

Dans un ReplicaSet, tous les replicas utilisent le même PersistentVolumeClaim !

.debug[[kube/statefulsets.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/statefulsets.md)]
---

## Les StatefulSets nous permettent d'avoir des noms uniques


![replicasets](images/replicasets_statefulsets.png)

Que se passe-t-il si un noeud meurt ?

.debug[[kube/statefulsets.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/statefulsets.md)]
---

class: pic

![replicasets](images/statefulset_nodefail.png)

.debug[[kube/statefulsets.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/statefulsets.md)]
---

## Statefulset, changement du nombre de replicas

![replicasets](images/statefulset_scaledown.png)

Le pod avec l'ID le plus grand est détruit en premier !

Mais qu'en est il des PVC attachés ?

.debug[[kube/statefulsets.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/statefulsets.md)]
---

class: pic


![replicasets](images/statefulsetPVC_scaledown.png)


.debug[[kube/statefulsets.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/statefulsets.md)]
---
## Statefulset exercises

- Les schemas ont été repris du livre de Marko Luksa "Kubernetes in Action"

.exercise[
- We will perform the exercise from the following link:
  https://blog.openshift.com/kubernetes-statefulset-in-action/

- with the following differences:
  * we won't use Openshift but our simple kubernetes cluster
  * instead of "ebs" storage class we will make use of our rook storage provisioner, so the manifests need to be adapted appropriately to fit our rook storage class

]
<!--

wget https://gist.githubusercontent.com/glesserd/5c8a55ae5844dd1d59b4ed1952bb5caa/raw/018e743ff39ac3ad0fe279c4d24add36cbb24d09/web.yaml

=> regardez le yaml!
===> headless service (clusterIP: None) => pas de load balancing, une entrée DNS  est créer (comme pour tout les services) et les endpoints sont mis dans ce DNS:
===> template, comme dans un replicaset (toujours nos selectors!)
===> volumeClaimTemplates


kubectl create -f web.yaml

kubectl run -i -t --rm dnscheck --restart=Never --image=alpine -- nslookup nginx
=> on retrouve nos 2 replicas!


dans un autre terminal, on va regarder ce qui se passe:

kubectl get pods -w -l app=nginx


kubectl create -f web.yaml

=> les pods sont créé dans l'ordre!
-->






.debug[[kube/statefulsets.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/statefulsets.md)]
---

class: pic

.interstitial[![Image separating from the next chapter](https://gallant-turing-d0d520.netlify.com/containers/plastic-containers.JPG)]

---

name: toc-autoscaling-avec-kubernetes
class: title

Autoscaling avec Kubernetes

.nav[
[Section précédente](#toc-statefulsets)
|
[Retour table des matières](#toc-chapter-7)
|
[Section suivante](#toc-cicd-with-spinnaker)
]

.debug[(automatically generated title slide)]

---
# Autoscaling avec Kubernetes

Nous allons mettre en place un système d'autoscaling basé sur k8s-prom-hpa. Ce logicil à l'avantage d'être simple, fonctionel et extensible grâce à Prometheus.

.exercise[
- Récupérez le logiciel:

  ```bash
git clone https://github.com/stefanprodan/k8s-prom-hpa.git
cd k8s-prom-hpa/
  ```

]

.debug[[kube/advanced_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/advanced_fr.md)]
---

## Récupérez les métriques

Déployons le *Metrics Server*, le server qui va récupérez les métriques sur les noeuds et les transmettre en utilisant l'API standard de kubernetes:

.exercise[
  ```bash
kubectl create -f ./metrics-server
  ```
]

(Avant k8s 1.8, Heapster permettait de faire cela. Ce projet a été fusionner avec Kubernetes pour faire *Metrics Server*.)

.debug[[kube/advanced_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/advanced_fr.md)]
---

## HorizontalPodAutoscaler CRD

.exercise[
La prochaine commande définit un nouveau type d'objet (un Custorm Resource Definition (CRD)), et lance le controlleur de ce CRD.

On peut donc maintenant intéragir avec le type HorizontalPodAutoscaler comme tout les autres objets de kubernetes:

  ```bash
kubectl get hpa
  ```

]

.debug[[kube/advanced_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/advanced_fr.md)]
---

## Déploiement d'une application

.exercise[
On deploie maintenant une application affichant sur une interface web des informations décrivant son pod:

  ```bash
kubectl create -f ./podinfo/podinfo-svc.yaml,./podinfo/podinfo-dep.yaml
  ```

Vous pouvez regarder ce que ces infos sont:
  ```bash
curl IP_PUBLIC:PORT_DU_SERVICE
  ```
]

.debug[[kube/advanced_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/advanced_fr.md)]
---

## Mise en place des règles d'auto-scaling

.exercise[
On va maintenant créer les règles HorizontalPodAutoscaler:

  ```bash
kubectl create -f ./podinfo/podinfo-hpa.yaml
  ```

Regardez ce yaml pour voir ce que définissent ces règles !

On a donc maintenant une nouvelle hpa:
  ```bash
kubectl get hpa
  ```
]

.debug[[kube/advanced_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/advanced_fr.md)]
---

## Stress de l'application

.exercise[
On va maintenant strésser le service pour que le scaling ce lance, dans un nouveau terminal :
  ```bash
cd ~/
mkdir golang
export GOPATH=~/golang/
export GOROOT=/usr/lib/go-1.10
export PATH=$GOPATH/bin:$GOROOT/bin:$PATH
go get -u github.com/rakyll/hey
hey -n 10000 -q 10 -c 5 http://IP_PUBLIC:PORT_DU_SERVICE/
  ```

]
.debug[[kube/advanced_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/advanced_fr.md)]
---

## Stress de l'application 2

.exercise[

Observez ce qui se passe pour le hpa:
  ```bash
kubectl describe hpa
  ```

]

L'autoscaler ne réagit pas immédiatement au pics d'utilisation.
Par défaut, les métriques sont synchronisées toutes les 30s.
De plus, le scaling up/down peut seulement avoir lieu si il n'y pas déjà eu un scaling dans les 5 minutes.
Cela permet au HPA de prendre des décisions trop rapides et/ou contradictoires.

.debug[[kube/advanced_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/advanced_fr.md)]
---

## En savoir plus

- The procedure is explained in detail and with more examples here: https://www.weave.works/blog/kubernetes-horizontal-pod-autoscaler-and-prometheus

- Pour reset:
  ```bash
kubectl delete -f ./podinfo/podinfo-hpa.yaml
kubectl delete -f ./podinfo/podinfo-svc.yaml,./podinfo/podinfo-dep.yaml
kubectl delete -f ./metrics-server
  ```







.debug[[kube/advanced_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/advanced_fr.md)]
---
---

class: pic

.interstitial[![Image separating from the next chapter](https://gallant-turing-d0d520.netlify.com/containers/train-of-containers-1.jpg)]

---

name: toc-cicd-with-spinnaker
class: title

CI/CD with Spinnaker

.nav[
[Section précédente](#toc-autoscaling-avec-kubernetes)
|
[Retour table des matières](#toc-chapter-7)
|
[Section suivante](#toc-dploiement-de-jupiter-sur-kubernetes)
]

.debug[(automatically generated title slide)]

---

# CI/CD with Spinnaker

.exercise[
- We will perform the exercise from the following link:
  https://thenewstack.io/getting-started-spinnaker-kubernetes/

 * However, since we already have our own cluster and Helm installed, we will start the tutorial from the "Installing Spinnaker" section

]


.debug[[kube/advanced_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/advanced_fr.md)]
---
---

class: pic

.interstitial[![Image separating from the next chapter](https://gallant-turing-d0d520.netlify.com/containers/train-of-containers-2.jpg)]

---

name: toc-dploiement-de-jupiter-sur-kubernetes
class: title

Déploiement de Jupiter sur Kubernetes

.nav[
[Section précédente](#toc-cicd-with-spinnaker)
|
[Retour table des matières](#toc-chapter-7)
|
[Section suivante](#toc-scheduling-avance-avec-kubernetes)
]

.debug[(automatically generated title slide)]

---

# Déploiement de Jupiter sur Kubernetes

.exercise[
- Nous suivrons la procédure fournie ici : 
  https://zonca.github.io/2017/12/scalable-jupyterhub-kubernetes-jetstream.html

]

.debug[[kube/advanced_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/advanced_fr.md)]
---

class: pic

.interstitial[![Image separating from the next chapter](https://gallant-turing-d0d520.netlify.com/containers/two-containers-on-a-truck.jpg)]

---

name: toc-scheduling-avance-avec-kubernetes
class: title

Scheduling avancée avec Kubernetes

.nav[
[Section précédente](#toc-dploiement-de-jupiter-sur-kubernetes)
|
[Retour table des matières](#toc-chapter-7)
|
[Section suivante](#toc-big-data-analytics-sur-kubernetes)
]

.debug[(automatically generated title slide)]

---
--- 

# Scheduling avancée avec Kubernetes

.exercise[
- Nous suivrons la procédure fournie ici : 
   https://github.com/RyaxTech/kube-tutorial#4-activate-an-advanced-scheduling-policy-and-test-its-usage
]

.debug[[kube/advanced_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/advanced_fr.md)]
---
---

class: pic

.interstitial[![Image separating from the next chapter](https://gallant-turing-d0d520.netlify.com/containers/wall-of-containers.jpeg)]

---

name: toc-big-data-analytics-sur-kubernetes
class: title

Big Data analytics sur Kubernetes

.nav[
[Section précédente](#toc-scheduling-avance-avec-kubernetes)
|
[Retour table des matières](#toc-chapter-7)
|
[Section suivante](#toc-)
]

.debug[(automatically generated title slide)]

---

# Big Data analytics sur Kubernetes

.exercise[
- Nous suivrons la procédure fournie ici :
https://github.com/RyaxTech/kube-tutorial#3-execute-big-data-job-with-spark-on-the-kubernetes-cluster
]



.debug[[kube/advanced_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/advanced_fr.md)]</textarea>
    <script src="remark.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create({
        ratio: '16:9',
        highlightSpans: true,
        excludedClasses: ["self-paced"]
      });
    </script>
    
    <!-- 
    These two scripts will be available only when loading the
    content using the pub/sub server. Otherwise, they'll just
    404 and that's OK.
    -->
    <script src="/socket.io/socket.io.js">
    </script>
    <script src="/remote.js">
    </script>

  </body>
</html>
