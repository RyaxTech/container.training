<!DOCTYPE html>
<html>
  <head>
    <title>Kubernetes  Stockage, Configuration, Secrets et Concepts Avancés  </title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" href="workshop.css">
  </head>
  <body>
    <!--
    <div style="position: absolute; left: 20%; right: 20%; top: 30%;">
      <h1 style="font-size: 3em;">Loading ...</h1>
      The slides should show up here. If they don't, it might be
      because you are accessing this file directly from your filesystem.
      It needs to be served from a web server. You can try this:
      <pre>
        docker-compose up -d
        open http://localhost:8888/workshop.html # on MacOS
        xdg-open http://localhost:8888/workshop.html # on Linux
      </pre>
      Once the slides are loaded, this notice disappears when you
      go full screen (e.g. by hitting "f").
    </div>
    -->
    <textarea id="source">class: title, self-paced

Kubernetes <br/>Stockage, Configuration, Secrets et Concepts Avancés <br/>

.nav[*Self-paced version*]

.debug[
```
 M intro-fullday.yml.html
 M intro-selfpaced.yml.html
 M kube-fullday.yml.html
 M kube-halfday.yml.html
 M kube-jour1.yml.html
 M kube-jour2.yml.html
 M kube-jour3.yml.html
 M kube-selfpaced.yml.html
 M kube/advanced_fr.md
 M kube/configs_fr.md
 M kube/stockage_fr.md
 M swarm-fullday.yml.html
 M swarm-halfday.yml.html
 M swarm-selfpaced.yml.html
 M swarm-video.yml.html
?? Kubernetes Introduction, Architecture et Installation.pdf

```

These slides have been built from commit: 2604bca


[common/title_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//common/title_fr.md)]
---

class: title, in-person

Kubernetes <br/>Stockage, Configuration, Secrets et Concepts Avancés <br/><br/></br>


.debug[[common/title_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//common/title_fr.md)]
---

name: toc-chapter-1

## Chapter 1

- [Introduction aux volumes](#toc-introduction-aux-volumes)

- [Introduction de PersistentVolumes et PersistentVolumeClaims](#toc-introduction-de-persistentvolumes-et-persistentvolumeclaims)

- [Provisionnement dynamique des volumes persistants](#toc-provisionnement-dynamique-des-volumes-persistants)

- [Rook orchestration de stockage distribué](#toc-rook-orchestration-de-stockage-distribu)

.debug[(auto-generated TOC)]
---
name: toc-chapter-2

## Chapter 2

- [Découplage de configuration avec un ConfigMap](#toc-dcouplage-de-configuration-avec-un-configmap)

- [Introduction des secrets](#toc-introduction-des-secrets)

.debug[(auto-generated TOC)]
---
name: toc-chapter-3

## Chapter 3

- [Isolation et politiques de réseau](#toc-isolation-et-politiques-de-rseau)

- [Déploiement de Jupiter sur Kubernetes](#toc-dploiement-de-jupiter-sur-kubernetes)

- [Scheduling avancée avec Kubernetes](#toc-scheduling-avance-avec-kubernetes)

- [Autoscaling avec Kubernetes](#toc-autoscaling-avec-kubernetes)

- [Big Data analytics sur Kubernetes](#toc-big-data-analytics-sur-kubernetes)

.debug[(auto-generated TOC)]



.debug[[common/toc.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//common/toc.md)]
---

class: pic

.interstitial[![Image separating from the next chapter](https://gallant-turing-d0d520.netlify.com/containers/Container-Ship-Freighter-Navigation-Elbe-Romance-1782991.jpg)]

---

name: toc-introduction-aux-volumes
class: title

Introduction aux volumes

.nav[
[Section précédente](#toc-)
|
[Retour table des matières](#toc-chapter-1)
|
[Section suivante](#toc-introduction-de-persistentvolumes-et-persistentvolumeclaims)
]

.debug[(automatically generated title slide)]

---
# Introduction aux volumes

- Les volumes de Kubernetes sont une composante d'un pod et sont donc définis dans la spécification de pods, tout comme les conteneurs.

- Ils ne sont pas un objet Kubernetes autonome et ne peuvent pas être créés ou supprimés par eux-mêmes.

- Un volume est disponible pour tous les conteneurs du pod, mais il doit être monté dans chaque conteneur qui doit y accéder.

- Dans chaque conteneur, vous pouvez monter le volume à n'importe quel emplacement de son système de fichiers.

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Les volumes par un exemple

- Conteneurs qui n'ont pas de stockage commune

- Conteneurs qui partageant 2 volumes montés dans des chemins de montage différents

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

class: pic

![haha seulement blague](images/volumes1.png)

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

class: pic

![haha seulement blague](images/volume2.png)

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---


## Remarques

- Les schemas ont été repris du livre de Marko Luksa "Kubernetes in Action"

- Le volume /var/logs n'est pas monté dans le conteneur ContentAgent.

- Le conteneur ne peut pas accéder à ses fichiers, même si le conteneur et le volume font partie du même conteneur.

- Il ne suffit pas de définir un volume dans le pod; vous devez également définir un VolumeMount dans la spécification du conteneur, si vous voulez que le conteneur puisse y accéder.

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Types de volume

- Une grande variété de types de volumes est disponible. Plusieurs sont génériques, tandis que d'autres sont spécifiques aux technologies de stockage utilisées en dessous.

* `emptyDir`: un répertoire vide simple utilisé pour stocker des données transitoires.
* `hostPath`: Utilisé pour monter les répertoires du système de fichiers du noeud worker dans le pod.
* `gitRepo`: Un volume initialisé en vérifiant le contenu d'un dépôt Git.
* `nfs`: un partage NFS monté dans le pod.
* `gcePersistentDisk`, `awsElasticBlockStore`, `azureDisk`: Utilisé pour monter le stockage spécifique au fournisseur de cloud.
* `cinder`, `cephfs`, ...: Utilisé pour monter d'autres types de stockage réseau.
* `configMap`, `secret`, `downwardAPI`: Types spéciaux de volumes utilisés pour exposer certaines ressources et informations de cluster Kubernetes au pod.
* `persistentVolumeClaim`: un moyen d'utiliser un stockage persistant pré-provisionné ou dynamiquement.

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Remarque

- Un seul pod peut utiliser plusieurs volumes de types différents en même temps

- Chacun des conteneurs du pod peut avoir le volume monté ou non.

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Exemple d'un pod utilisant le volume gitrepo

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

.exercise[
  ```bash
apiVersion: v1
kind: Pod
metadata:
  name: gitrepo-volume-pod
spec:
  containers:
  - image: nginx:alpine
    name: web-server
    volumeMounts:
    - name: html
      mountPath: /usr/share/nginx/html
      readOnly: true
    ports:
    - containerPort: 80
      protocol: TCP
  volumes:
  - name: html
    gitRepo:
      repository: https://github.com/luksa/kubia-website-example.git
      revision: master
      directory: .   
  ```
]

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Découplage des pods de la technologie de stockage sous-jacente

- Le cas ci-dessus est contre l'idée de base de Kubernetes, qui vise à cacher l'infrastructure réelle de l'application et de son développeur.

- Lorsqu'un développeur a besoin d'une certaine quantité de stockage persistant pour son application, il doit le demander à Kubernetes.

- De la même manière qu'ils demandent du CPU, de la mémoire et d'autres ressources lors de la création d'un pod.

- L'administrateur système peut configurer le cluster afin qu'il puisse donner aux applications ce qu'elles demandent.

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

class: pic

.interstitial[![Image separating from the next chapter](https://gallant-turing-d0d520.netlify.com/containers/ShippingContainerSFBay.jpg)]

---

name: toc-introduction-de-persistentvolumes-et-persistentvolumeclaims
class: title

Introduction de PersistentVolumes et PersistentVolumeClaims

.nav[
[Section précédente](#toc-introduction-aux-volumes)
|
[Retour table des matières](#toc-chapter-1)
|
[Section suivante](#toc-provisionnement-dynamique-des-volumes-persistants)
]

.debug[(automatically generated title slide)]

---

# Introduction de PersistentVolumes et PersistentVolumeClaims

- Au lieu que le développeur ajoute un volume spécifique à son pod, c'est l'administrateur du cluster qui configure le stockage sous-jacent, puis l'enregistre dans
Kubernetes en créant une ressource PersistentVolume via le serveur de l'API Kubernetes.

- Lors de la création de PersistentVolume, l'administrateur spécifie sa taille et les modes d'accès
qu'il supporte.

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Introduction de PersistentVolumes et PersistentVolumeClaims

- Lorsqu'un utilisateur de cluster doit utiliser un stockage persistant dans l'un de ses pods, il crée d'abord un manifeste PersistentVolumeClaim, en spécifiant la taille minimale et le mode d'accès qu'ils exigent.

- L'utilisateur soumet ensuite le manifeste PersistentVolumeClaim au serveur de l'API Kubernetes, et Kubernetes trouve le PersistentVolume approprié et lie au Volume Claim.

- Le PersistentVolumeClaim peut alors être utilisé comme l'un des volumes à l'intérieur d'un pod. Les autres utilisateurs ne peuvent pas utiliser le même PersistentVolume jusqu'à ce qu'il ait été libéré en supprimant
le PersistentVolumeClaim lié.

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Exemple de PersistentVolumes et PersistentVolumeClaims

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

class: pic

![haha seulement blague](images/volumes3.png)

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## PersistentVolumes et Namespaces

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

class: pic

![haha seulement blague](images/Volume4.png)

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Durée de vie de PersistentVolume et PersistentVolumeClaims

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

class: pic

![haha seulement blague](images/Volume5.png)

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

class: pic

.interstitial[![Image separating from the next chapter](https://gallant-turing-d0d520.netlify.com/containers/aerial-view-of-containers.jpg)]

---

name: toc-provisionnement-dynamique-des-volumes-persistants
class: title

Provisionnement dynamique des volumes persistants

.nav[
[Section précédente](#toc-introduction-de-persistentvolumes-et-persistentvolumeclaims)
|
[Retour table des matières](#toc-chapter-1)
|
[Section suivante](#toc-rook-orchestration-de-stockage-distribu)
]

.debug[(automatically generated title slide)]

---
# Provisionnement dynamique des volumes persistants

- Les schemas précédents ont été repris du livre de Marko Luksa "Kubernetes in Action"

- Nous avons vu comment l'utilisation de PersistentVolumes et PersistentVolumeClaims facilite l'obtention d'un stockage persistant sans que le développeur n'ait à gérer le stockage réel utilisée en dessous.

- Mais cela nécessite toujours un administrateur de cluster pour provisionner le stockage réel à l'avance.

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Provisionnement dynamique des volumes persistants

- Heureusement, Kubernetes peut également effectuer ce travail automatiquement grâce au provisionnement dynamique de PersistentVolumes.

- L'administrateur du cluster, au lieu de créer PersistentVolumes, peut déployer un provisionneur PersistentVolume et définir un ou plusieurs objets StorageClass pour permettre aux utilisateurs de choisir le type de PersistentVolume souhaité.

- Les utilisateurs peuvent se référer à StorageClass dans leur PersistanceVolumeClaims et le provisionneur en tiendra compte lors de l'approvisionnement du stockage persistant.

- Le schema suivant a été repris du livre de Marko Luksa "Kubernetes in Action" 

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Provisionnement dynamique des volumes persistants

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

class: pic

![haha seulement blague](images/volume6.png)

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

class: pic

.interstitial[![Image separating from the next chapter](https://gallant-turing-d0d520.netlify.com/containers/blue-containers.jpg)]

---

name: toc-rook-orchestration-de-stockage-distribu
class: title

Rook orchestration de stockage distribué

.nav[
[Section précédente](#toc-provisionnement-dynamique-des-volumes-persistants)
|
[Retour table des matières](#toc-chapter-1)
|
[Section suivante](#toc-dcouplage-de-configuration-avec-un-configmap)
]

.debug[(automatically generated title slide)]

---

# Rook orchestration de stockage distribué

- Rook est un orchestrateur open source pour les systèmes de stockage distribués.

- Rook transforme le logiciel de stockage distribué en un service de stockage auto-géré, auto-scalable et auto-guérisant.

- Il le fait en automatisant le déploiement, l'amorçage, la configuration, l'approvisionnement, la mise à l'échelle, la mise à niveau, la migration, la reprise après sinistre, la surveillance et la gestion des ressources.

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Rook orchestration de stockage distribué

- Rook se concentre d'abord sur l'orchestration de Ceph sur Kubernetes. Ceph est un système de stockage distribué qui permet le stockage de fichiers, de blocs et d'objets et qui est déployé dans des clusters de production à grande échelle.

- Rook est hébergé par la Cloud Native Computing Foundation (CNCF) en tant que projet de niveau initial.

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Exemple de provisionnement dynamique de PersistentVolumes à l'aide de Rook

.exercise[
  ```bash
   git clone https://github.com/rook/rook.git
   cd rook/cluster/examples/kubernetes/ceph
   kubectl create -f operator.yaml
   kubect create -f cluster.yaml
  ```
- vérifiez pour voir si tout fonctionne comme prévu
  ```bash
   kubectl get pods -n rook-ceph
  ```

]

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Exemple de provisionnement dynamique de PersistentVolumes à l'aide de Rook

- Le stockage 'block' vous permet de monter le stockage dans un seul pod.

- Voyons comment construire une application web simple et multi-niveaux sur Kubernetes en utilisant des volumes persistants activés par Rook.

--

- Avant que Rook puisse démarrer le provisionnement, une classe StorageClass et son pool de stockage doivent être créés.

- Ceci est nécessaire pour que Kubernetes puisse interopérer avec Rook pour provisionner des volumes persistants.

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---
## Exemple de provisionnement dynamique de PersistentVolumes à l'aide de Rook

.exercise[
- Créez le pool et le storage class:
  ```bash
  kubectl create -f pool.yaml
  kubectl create -f storageclass.yaml
  ```
]
- Consommez le stockage avec l'échantillon wordpress
- Nous créons un exemple d'application pour consommer le stockage en 'block' provisionné par Rook avec les applications classiques wordpress et mysql.
- Ces deux applications utiliseront les volumes 'block' provisionnés par Rook.

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Exemple de provisionnement dynamique de PersistentVolumes à l'aide de Rook


.exercise[
- Démarrez mysql et wordpress depuis le dossier cluster/examples/kubernetes:
  ```bash
  kubectl create -f mysql.yaml
  kubectl create -f wordpress.yaml
  ```
- Ces deux applications créent un volume en 'block' et le montent dans leur pod respectif. Vous pouvez voir les 'volume claims' de Kubernetes en exécutant les opérations suivantes:

  ```bash
  kubectl get pvc
  ```
- Vous devriez voir quelque chose comme ça:
```bash
NAME             STATUS    VOLUME        CAPACITY   ACCESSMODES   AGE
mysql-pv-claim   Bound     pvc-954459ee   20Gi       RWO           1m
wp-pv-claim      Bound     pvc-39e459ee   20Gi       RWO           1m
```
]
.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Exemple de provisionnement dynamique de PersistentVolumes à l'aide de Rook

.exercise[
- Une fois que les pods wordpress et mysql sont dans l'état Running, récupérez l'adresse IP du cluster de l'application wordpress et entrez-la dans votre navigateur avec le port:

 ```bash
 kubectl get svc wordpress
 ```
]
Vous devriez voir l'application wordpress en cours d'exécution.

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Lancez un autre exemple de provisionnement dynamique

.exercise[

- Copiez le fichier à partir d'ici: https://github.com/zonca/jupyterhub-deploy-kubernetes-jetstream/blob/master/storage_rook/alpine-rook.yaml

- Modifiez-le pour qu'il corresponde aux spécifications de votre cluster et exécutez-le en utilisant:
  ```bash
  kubectl create -f alpine-rook.yaml
  ```

]

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Lancez un autre exemple de provisionnement dynamique (suite)

- C'est un petit pod avec Alpine Linux qui crée un volume de 2 Go à partir de Rook et le monte sur /data.

- Cela crée un Pod avec Alpine Linux qui demande qu'un Persistent Volume Claim soit montée sous /data.

- Le PersistentVolumeClaim spécifiait le type de stockage et sa taille.

- Une fois le Pod créé, il demande au PersistentVolumeClaim de demander à Rook de préparer un volume persistant qui sera ensuite monté dans le pod.

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Lancez un autre exemple de provisionnement dynamique (suite)

- Nous pouvons vérifier que les Volumes Persistants sont créés et associés au pod, vérifiez:

.exercice[
  ```bash
  kubectl get pv
  kubectl get pvc
  kubectl get logs alpine
  ```
- Obtenez un shell dans le pod avec:
  ```bash
  kubectl exec -it alpine - /bin/sh
  ```
- Access /data/ et écrire des fichiers.
- Quitter le terminal
- Maintenant supprimez le pod et voyez si vous pouvez récupérer les données que vous avez écrites.
]

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---
## Lancez un autre exemple de provisionnement dynamique (suite)

.exercice[
- Comment aurions-nous pu récupérer les données dans le dernier cas?
- Changeons alpine-rook.yaml en `kind:deployment`, écrivez quelques fichiers et tuez à nouveau le pod pour voir ce qui se passe.
]



.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

class: pic

.interstitial[![Image separating from the next chapter](https://gallant-turing-d0d520.netlify.com/containers/chinook-helicopter-container.jpg)]

---

name: toc-dcouplage-de-configuration-avec-un-configmap
class: title

Découplage de configuration avec un ConfigMap

.nav[
[Section précédente](#toc-rook-orchestration-de-stockage-distribu)
|
[Retour table des matières](#toc-chapter-2)
|
[Section suivante](#toc-introduction-des-secrets)
]

.debug[(automatically generated title slide)]

---
# Découplage de configuration avec un ConfigMap

- Le but de la configuration d'une application est de garder les options de configuration qui varient d'un environnement à l'autre, ou de changer fréquemment, séparément de la source de l'application
code.

- Si vous considérez un descripteur de pod comme un code source pour votre application (il définit comment composer les composants individuels dans un système fonctionnel), il est clair que vous devez supprimer la configuration de la description du pod.

.debug[[kube/configs_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/configs_fr.md)]
---

## Introduction de ConfigMap

- Kubernetes permet de séparer les options de configuration en un objet distinct appelé ConfigMap, qui est une carte contenant des paires clé / valeur avec des valeurs allant de
des littéraux courts aux fichiers de configuration complets.

- Une application n'a pas besoin de lire directement le ConfigMap ou même de savoir qu'il existe. Le contenu de la carte est plutôt transmis aux conteneurs comme environnement
variables ou en tant que fichiers dans un volume.

.debug[[kube/configs_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/configs_fr.md)]
---

## Introduction de ConfigMap

- Vous pouvez définir les entrées de la carte en transmettant des littéraux à la commande kubectl ou vous pouvez créer ConfigMap à partir de fichiers stockés sur votre disque.

- Utilisez un littéral simple en premier:

.exercise[
  ```bash
  kubectl create configmap fortune-config --from-literal=sleep-interval=25
  ```

- REMARQUE Les clés ConfigMap doivent être un sous-domaine DNS valide (elles ne peuvent contenir que des caractères alphanumériques, des tirets, des traits de soulignement et des points). Ils peuvent éventuellement inclure un point leader.
]

.debug[[kube/configs_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/configs_fr.md)]
---

## Explication de Configmaps dans un exemple

- Exécutez l'exemple décrit ici: https://kubernetes.io/docs/tutorials/configuration/configure-redis-using-configmap/


.debug[[kube/configs_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/configs_fr.md)]
---

class: pic

.interstitial[![Image separating from the next chapter](https://gallant-turing-d0d520.netlify.com/containers/container-cranes.jpg)]

---

name: toc-introduction-des-secrets
class: title

Introduction des secrets

.nav[
[Section précédente](#toc-dcouplage-de-configuration-avec-un-configmap)
|
[Retour table des matières](#toc-chapter-2)
|
[Section suivante](#toc-isolation-et-politiques-de-rseau)
]

.debug[(automatically generated title slide)]

---

# Introduction des secrets

- Kubernetes fournit un objet séparé appelé Secret. Les secrets ressemblent beaucoup à ConfigMaps

- Ce sont aussi des cartes qui contiennent des paires clé-valeur. Ils peuvent être utilisés de la même manière qu'un ConfigMap.

- Vous pouvez passer des entrées secrètes au conteneur en tant que variables d'environnement

- Expose les entrées secrètes en tant que fichiers dans un volume

.debug[[kube/configs_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/configs_fr.md)]
---

## Introduction des secrets

- Kubernetes aide à garder vos secrets en toute sécurité en s'assurant que chaque secret est seulement distribué
aux nœuds qui exécutent les pods qui ont besoin d'accéder au secret.

- De plus, sur les nœuds eux-mêmes, les Secrets sont toujours stockés en mémoire et jamais écrits dans le stockage physique,
ce qui nécessiterait de nettoyer les disques après avoir supprimé les secrets d'eux.

.debug[[kube/configs_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/configs_fr.md)]
---
## Introduction des secrets

- Sur le nœud maître proprement dit, etcd stocke les secrets sous forme cryptée, ce qui rend le système beaucoup plus sécurisé. Pour cette raison, il est impératif que vous choisissez correctement quand utiliser un Secret ou un ConfigMap. Choisir entre eux est simple:

 * Utilisez un fichier ConfigMap pour stocker des données de configuration non sensibles et simples.
--

 * Utilisez un secret pour stocker toutes les données sensibles et doivent être conservées sous clé. Si un fichier de configuration contient des données sensibles mais aussi non sensibles, vous
devrez stocker le fichier dans un secret.

.debug[[kube/configs_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/configs_fr.md)]
---

## Exercices utilisant des secrets

- Quelques exercices initiaux utilisant Secrets peuvent être trouvés ici: https://kubernetes.io/docs/concepts/configuration/secret/

.debug[[kube/configs_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/configs_fr.md)]
---

class: pic

.interstitial[![Image separating from the next chapter](https://gallant-turing-d0d520.netlify.com/containers/container-housing.jpg)]

---

name: toc-isolation-et-politiques-de-rseau
class: title

Isolation et politiques de réseau

.nav[
[Section précédente](#toc-introduction-des-secrets)
|
[Retour table des matières](#toc-chapter-3)
|
[Section suivante](#toc-dploiement-de-jupiter-sur-kubernetes)
]

.debug[(automatically generated title slide)]

---
# Isolation et politiques de réseau

- Les Namespaces *ne fournissent pas* de l'isolation

- Un pod dans un namespace vert peut communiquer avec un pod dans le namespace bleu.

- Un pod dans le namespace `default` peut communiquer avec un pod dans le namespace `kube-system`.

- kube-dns utilise un sous-domaine différent pour chaque espace de nommage

- Exemple : à partir de n'importe quel pod du cluster, vous pouvez vous connecter à l'API Kubernetes avec :

  `https://kubernetes.default.svc.cluster.local:443/`

.debug[[kube/advanced_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/advanced_fr.md)]
---

## Isolation de pods

- L'isolement réel est mis en œuvre avec des *politiques de réseau* (network policies).

- Les politiques réseau sont des ressources (comme les déploiements, les services, les namespaces....).

- Les politiques de réseau spécifient les flux autorisés :

  - entre les pods

  - du pod au monde extérieur

  - et vice-versa

.debug[[kube/advanced_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/advanced_fr.md)]
---

## Network policies

- Nous pouvons créer autant de politiques de réseau que nous le voulons.

- Chaque politique de réseau a :

  - un *pod selector* : "Quelles sont les pods visées par la politique ?"

  - des listes de règles d'entrée (ingress) et/ou de sortie (egress) : "Quels pairs et ports sont autorisés ou bloqués ?"

- Si un pod n'est pas visé par une politique, le trafic est autorisé par défaut.

- Si un pod est visé par au moins une politique, le trafic doit être explicitement autorisé.

.debug[[kube/advanced_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/advanced_fr.md)]
---

## Plus d'infos sur Network policies 

- Pour plus de détails, vérifiez :

  - la documentation de Kubernetes sur les politiques de réseau](https://kubernetes.io/docs/concepts/services-networking/network-policies/)

  - ce [talk sur network policies fait au KubeCon 2017 US](https://www.youtube.com/watch?v=3gGpMmYeEO8) par [@ahmetb](https://twitter.com/ahmetb)

.debug[[kube/advanced_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/advanced_fr.md)]
---

## Exercices sur les Network policies

.exercise[
- Pour exécuter quelques exercices sur les politiques de réseau, nous allons suivre quelques exemples ici : 
  https://github.com/ahmetb/kubernetes-network-policy-recipes
]

.debug[[kube/advanced_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/advanced_fr.md)]
---

class: pic

.interstitial[![Image separating from the next chapter](https://gallant-turing-d0d520.netlify.com/containers/containers-by-the-water.jpg)]

---

name: toc-dploiement-de-jupiter-sur-kubernetes
class: title

Déploiement de Jupiter sur Kubernetes

.nav[
[Section précédente](#toc-isolation-et-politiques-de-rseau)
|
[Retour table des matières](#toc-chapter-3)
|
[Section suivante](#toc-scheduling-avance-avec-kubernetes)
]

.debug[(automatically generated title slide)]

---

# Déploiement de Jupiter sur Kubernetes

.exercise[
- Nous suivrons la procédure fournie ici : 
  https://zonca.github.io/2017/12/scalable-jupyterhub-kubernetes-jetstream.html
]

.debug[[kube/advanced_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/advanced_fr.md)]
---

class: pic

.interstitial[![Image separating from the next chapter](https://gallant-turing-d0d520.netlify.com/containers/distillery-containers.jpg)]

---

name: toc-scheduling-avance-avec-kubernetes
class: title

Scheduling avancée avec Kubernetes

.nav[
[Section précédente](#toc-dploiement-de-jupiter-sur-kubernetes)
|
[Retour table des matières](#toc-chapter-3)
|
[Section suivante](#toc-autoscaling-avec-kubernetes)
]

.debug[(automatically generated title slide)]

---
--- 

# Scheduling avancée avec Kubernetes

.exercise[
- Nous suivrons la procédure fournie ici : 
   https://github.com/RyaxTech/kube-tutorial#4-activate-an-advanced-scheduling-policy-and-test-its-usage
]
.debug[[kube/advanced_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/advanced_fr.md)]
---
---

class: pic

.interstitial[![Image separating from the next chapter](https://gallant-turing-d0d520.netlify.com/containers/lots-of-containers.jpg)]

---

name: toc-autoscaling-avec-kubernetes
class: title

Autoscaling avec Kubernetes

.nav[
[Section précédente](#toc-scheduling-avance-avec-kubernetes)
|
[Retour table des matières](#toc-chapter-3)
|
[Section suivante](#toc-big-data-analytics-sur-kubernetes)
]

.debug[(automatically generated title slide)]

---
# Autoscaling avec Kubernetes

.exercise[
- Nous suivrons la procédure fournie ici : 
  https://github.com/RyaxTech/kube-tutorial#6-enable-and-use-pod-autoscaling
]
.debug[[kube/advanced_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/advanced_fr.md)]
---
---

class: pic

.interstitial[![Image separating from the next chapter](https://gallant-turing-d0d520.netlify.com/containers/plastic-containers.JPG)]

---

name: toc-big-data-analytics-sur-kubernetes
class: title

Big Data analytics sur Kubernetes

.nav[
[Section précédente](#toc-autoscaling-avec-kubernetes)
|
[Retour table des matières](#toc-chapter-3)
|
[Section suivante](#toc-)
]

.debug[(automatically generated title slide)]

---
# Big Data analytics sur Kubernetes

.exercise[
- Nous suivrons la procédure fournie ici :
https://github.com/RyaxTech/kube-tutorial#3-execute-big-data-job-with-spark-on-the-kubernetes-cluster
]



.debug[[kube/advanced_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/advanced_fr.md)]</textarea>
    <script src="remark.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create({
        ratio: '16:9',
        highlightSpans: true,
        excludedClasses: ["self-paced"]
      });
    </script>
    
    <!-- 
    These two scripts will be available only when loading the
    content using the pub/sub server. Otherwise, they'll just
    404 and that's OK.
    -->
    <script src="/socket.io/socket.io.js">
    </script>
    <script src="/remote.js">
    </script>

  </body>
</html>
