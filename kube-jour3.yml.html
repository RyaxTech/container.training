<!DOCTYPE html>
<html>
  <head>
    <title>Kubernetes  Stockage, Configuration, Secrets et Concepts Avancés  </title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" href="workshop.css">
    <link rel="stylesheet" href="override.css">
  </head>
  <body>
    <!--
    <div style="position: absolute; left: 20%; right: 20%; top: 30%;">
      <h1 style="font-size: 3em;">Loading ...</h1>
      The slides should show up here. If they don't, it might be
      because you are accessing this file directly from your filesystem.
      It needs to be served from a web server. You can try this:
      <pre>
        docker-compose up -d
        open http://localhost:8888/workshop.html # on MacOS
        xdg-open http://localhost:8888/workshop.html # on Linux
      </pre>
      Once the slides are loaded, this notice disappears when you
      go full screen (e.g. by hitting "f").
    </div>
    -->
    <textarea id="source">class: title, self-paced

Kubernetes <br/>Stockage, Configuration, Secrets et Concepts Avancés <br/>

.nav[*Self-paced version*]

.debug[
```
 M common/prereqs_fr.md
 M common/sampleapp_fr.md
 M dock-kube-day1.yml.html
 M dock-kube-day2.yml.html
 M dock-kube-day3.yml.html
 M dock-kube-day4.yml.html
 M index.html
 M intro-fullday.yml.html
 M intro-selfpaced.yml.html
 M kube-day1.yml.html
 M kube-fullday.yml.html
 M kube-halfday.yml.html
 M kube-jour1.yml.html
 M kube-jour2.yml
 M kube-jour2.yml.html
 M kube-jour3.yml
 M kube-jour3.yml.html
 M kube-selfpaced.yml.html
 M kube/daemonset_fr.md
 M kube/dashboard_fr.md
 M kube/kubectlexpose_fr.md
 M kube/kubeobjects_fr.md
 D kube/recapj1_fr.md
 D kube/recapj2_fr.md
 M logistics_david.md
 M override.css
 M spark-day2-PE.yml.html
 M swarm-fullday.yml.html
 M swarm-halfday.yml.html
 M swarm-selfpaced.yml.html
 M swarm-video.yml.html
 M tp_wordpress.yml.html
 M workshop.html
?? .directory
?? common/.directory
?? exemples.md
?? exemples.yml
?? exemples.yml.html
?? index_spark.html
?? intro/.directory
?? kube/.directory
?? kube/exo-ab-testing/
?? kube/exo-wordpress/
?? lite.render.js
?? prepare-vms/.directory
?? prepare-vms/lib/.directory
?? prepare-vms/settings/.directory
?? swarm/.directory
?? viz.js

```

These slides have been built from commit: b090a14


[common/title_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//common/title_fr.md)]
---

class: title, in-person

Kubernetes <br/>Stockage, Configuration, Secrets et Concepts Avancés <br/><br/></br>


.debug[[common/title_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//common/title_fr.md)]
---

name: toc-chapter-1

## Chapter 1

- [Serverless](#toc-serverless)

.debug[(auto-generated TOC)]
---
name: toc-chapter-2

## Chapter 2

- [Introduction aux volumes](#toc-introduction-aux-volumes)

- [Introduction de PersistentVolumes et PersistentVolumeClaims](#toc-introduction-de-persistentvolumes-et-persistentvolumeclaims)

- [Provisionnement dynamique des volumes persistants](#toc-provisionnement-dynamique-des-volumes-persistants)

- [Rook orchestration de stockage distribué](#toc-rook-orchestration-de-stockage-distribu)

.debug[(auto-generated TOC)]
---
name: toc-chapter-3

## Chapter 3

- [Exercice A/B testing, la suite](#toc-exercice-ab-testing-la-suite)

.debug[(auto-generated TOC)]
---
name: toc-chapter-4

## Chapter 4

- [Découplage de configuration avec un ConfigMap](#toc-dcouplage-de-configuration-avec-un-configmap)

- [Introduction des secrets](#toc-introduction-des-secrets)

.debug[(auto-generated TOC)]
---
name: toc-chapter-5

## Chapter 5

- [Monitoring avec Prometheus et Grafana](#toc-monitoring-avec-prometheus-et-grafana)

.debug[(auto-generated TOC)]
---
name: toc-chapter-6

## Chapter 6

- [StatefulSets](#toc-statefulsets)

.debug[(auto-generated TOC)]
---
name: toc-chapter-7

## Chapter 7

- [TP Wordpress](#toc-tp-wordpress)

- [C'est parti !](#toc-cest-parti-)

.debug[(auto-generated TOC)]
---
name: toc-chapter-8

## Chapter 8

- [Autoscaling avec Kubernetes](#toc-autoscaling-avec-kubernetes)

- [CI/CD with Spinnaker](#toc-cicd-with-spinnaker)

- [Déploiement de Jupiter sur Kubernetes](#toc-dploiement-de-jupiter-sur-kubernetes)

- [Scheduling avancée avec Kubernetes](#toc-scheduling-avance-avec-kubernetes)

- [Big Data analytics sur Kubernetes](#toc-big-data-analytics-sur-kubernetes)

.debug[(auto-generated TOC)]



.debug[[common/toc.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//common/toc.md)]
---

class: pic

.interstitial[![Image separating from the next chapter](https://gallant-turing-d0d520.netlify.com/containers/Container-Ship-Freighter-Navigation-Elbe-Romance-1782991.jpg)]

---

name: toc-serverless
class: title

Serverless

.nav[
[Section précédente](#toc-)
|
[Retour table des matières](#toc-chapter-1)
|
[Section suivante](#toc-introduction-aux-volumes)
]

.debug[(automatically generated title slide)]

---

# Serverless

.debug[[kube/serverless_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/serverless_fr.md)]
---
class: pic

![apigateway](images/serverless_apigateway.png)

.debug[[kube/serverless_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/serverless_fr.md)]
---

## Exemple d'une fonction serverless
```python
import json, logging, os, time, uuid
import boto3
dynamodb = boto3.resource('dynamodb')

def create(event, context):
    data = json.loads(event['body'])
    table = dynamodb.Table(os.environ['DYNAMODB_TABLE'])

    item = {
        'id': str(uuid.uuid1()),
        'text': data['text'],
        'createdAt': int(time.time() * 1000),
    }

    table.put_item(Item=item)
    return {
        "statusCode": 200,
        "body": json.dumps(item)
    }
```
.debug[[kube/serverless_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/serverless_fr.md)]
---

## Que faire de ça ?

1) l'uploader sur une plateforme de serverless

2) configurer l'API Gateway de cette plateforme pour que la fonction soit appelé lors d'un evenement choisi.


.debug[[kube/serverless_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/serverless_fr.md)]
---

## Les avantages du serverless

- Pas d'administration (pour l'utilisateur)

- Auto-scaling

- Pay-per-use

- déployer plus souvent et plus rapidement

- Applications multi-language

- Le développeur n'a pas à se soucier de la scalabilité de son code

.debug[[kube/serverless_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/serverless_fr.md)]
---

## Les défauts du serverless

- Le développeur n'a pas à se soucier de la scalabilité de son code
    - la difficulté de parallélisation est dans la base de donnée sous jacente (ex: dynamoDB)

- Plus d'éléments indépendants à gérer

- Une erreur peut être propager à travers plusieurs fonctions avant de causer des problèmes

- Programmer des fonctions *"purs"* peut être difficile

- Les sysadmins changent du code (en mettant à jour par exemple python), sans connaitre le code qui l'utilise => possibilité de bugs!


.debug[[kube/serverless_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/serverless_fr.md)]
---

## Les Use Cases

- Gestion de contenu (ex: genérer des aperçus d'images)
- Traiter des évenements venant de SaaS (ex: quand un msg "pizza" reçu sur slack, commander un pizza)
- Auto-scaling des sites webs et des APIs
- Hybrid-cloud Applications
- Data Pipeline, principalement du Extract-Transform-Load
- Notifications
- Real time update
- Client access : un fonction pour valider un token
- Live data migration
- CI/CD


.debug[[kube/serverless_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/serverless_fr.md)]
---

## Exemple de use case


- Exemple avec un site web de livraison mensuel de box de chocolats:

    - le frontend est gérer par un service wordpress
    - les formulaires sont géré par un service externe (ex: formstack)
    - le paiement est géré par un service externe (ex: stripe, paypal)
    - la base de donnée client est géré par un service externe (ex: google sheet, firebase)
    - la gestion des stocks est faites via un service externe (ex: Odoo, SAP)
    - quand un nouvel utilisateur s'enregistre, ses informations sont rajouté dans la base client
    - quand un nouveau client est entrée dans la base, la commande est ajouter dans le gestionnaire de stock
    - quand un nouveau mail apparet dans la base client, des mails marketing sont envoyé (pour acheter des *super* boites, avec plus de chocolats)
    - ...

.debug[[kube/serverless_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/serverless_fr.md)]
---

## Le serverless permet un découplage

- Une application coder avec du serverless permet de découpler les services, des données, de l'intéligence.

- Le developpeur a juste à connécter les bons services entre eux.

- Voir "API economy".



.debug[[kube/serverless_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/serverless_fr.md)]
---

class: pic
![Landscape](images/CloudNativeLandscape_Serverless_latest.png)

.debug[[kube/serverless_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/serverless_fr.md)]
---

class: pic

.interstitial[![Image separating from the next chapter](https://gallant-turing-d0d520.netlify.com/containers/ShippingContainerSFBay.jpg)]

---

name: toc-introduction-aux-volumes
class: title

Introduction aux volumes

.nav[
[Section précédente](#toc-serverless)
|
[Retour table des matières](#toc-chapter-2)
|
[Section suivante](#toc-introduction-de-persistentvolumes-et-persistentvolumeclaims)
]

.debug[(automatically generated title slide)]

---
# Introduction aux volumes

- Les volumes de Kubernetes sont une composante d'un pod et sont donc définis dans la spécification de pods, tout comme les conteneurs.

- Ils ne sont pas un objet Kubernetes autonome et ne peuvent pas être créés ou supprimés par eux-mêmes.

- Un volume est disponible pour tous les conteneurs du pod, mais il doit être monté dans chaque conteneur qui doit y accéder.

- Dans chaque conteneur, vous pouvez monter le volume à n'importe quel emplacement de son système de fichiers.

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Les volumes par un exemple

- Conteneurs qui n'ont pas de stockage commune

- Conteneurs qui partageant 2 volumes montés dans des chemins de montage différents

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

class: pic

![haha seulement blague](images/volumes1.png)

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

class: pic

![haha seulement blague](images/volume2.png)

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---


## Remarques

- Les schemas ont été repris du livre de Marko Luksa "Kubernetes in Action"

- Le volume /var/logs n'est pas monté dans le conteneur ContentAgent.

- Le conteneur ne peut pas accéder à ses fichiers, même si le conteneur et le volume font partie du même conteneur.

- Il ne suffit pas de définir un volume dans le pod; vous devez également définir un VolumeMount dans la spécification du conteneur, si vous voulez que le conteneur puisse y accéder.

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Types de volume

- Une grande variété de types de volumes est disponible. Plusieurs sont génériques, tandis que d'autres sont spécifiques aux technologies de stockage utilisées en dessous.

* `emptyDir`: un répertoire vide simple utilisé pour stocker des données transitoires.
* `hostPath`: Utilisé pour monter les répertoires du système de fichiers du noeud worker dans le pod.
* `gitRepo`: Un volume initialisé en vérifiant le contenu d'un dépôt Git.
* `nfs`: un partage NFS monté dans le pod.
* `gcePersistentDisk`, `awsElasticBlockStore`, `azureDisk`: Utilisé pour monter le stockage spécifique au fournisseur de cloud.
* `cinder`, `cephfs`, ...: Utilisé pour monter d'autres types de stockage réseau.
* `configMap`, `secret`, `downwardAPI`: Types spéciaux de volumes utilisés pour exposer certaines ressources et informations de cluster Kubernetes au pod.
* `persistentVolumeClaim`: un moyen d'utiliser un stockage persistant pré-provisionné ou dynamiquement.

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Remarque

- Un seul pod peut utiliser plusieurs volumes de types différents en même temps

- Chacun des conteneurs du pod peut avoir le volume monté ou non.

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Exemple d'un pod utilisant le volume gitrepo

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

.exercise[
  ```bash
apiVersion: v1
kind: Pod
metadata:
  name: gitrepo-volume-pod
spec:
  containers:
  - image: nginx:alpine
    name: web-server
    volumeMounts:
    - name: html
      mountPath: /usr/share/nginx/html
      readOnly: true
    ports:
    - containerPort: 80
      protocol: TCP
  volumes:
  - name: html
    gitRepo:
      repository: https://github.com/luksa/kubia-website-example.git
      revision: master
      directory: .   
  ```
]

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Découplage des pods de la technologie de stockage sous-jacente

- Le cas ci-dessus est contre l'idée de base de Kubernetes, qui vise à cacher l'infrastructure réelle de l'application et de son développeur.

- Lorsqu'un développeur a besoin d'une certaine quantité de stockage persistant pour son application, il doit le demander à Kubernetes.

- De la même manière qu'ils demandent du CPU, de la mémoire et d'autres ressources lors de la création d'un pod.

- L'administrateur système peut configurer le cluster afin qu'il puisse donner aux applications ce qu'elles demandent.

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

class: pic

.interstitial[![Image separating from the next chapter](https://gallant-turing-d0d520.netlify.com/containers/aerial-view-of-containers.jpg)]

---

name: toc-introduction-de-persistentvolumes-et-persistentvolumeclaims
class: title

Introduction de PersistentVolumes et PersistentVolumeClaims

.nav[
[Section précédente](#toc-introduction-aux-volumes)
|
[Retour table des matières](#toc-chapter-2)
|
[Section suivante](#toc-provisionnement-dynamique-des-volumes-persistants)
]

.debug[(automatically generated title slide)]

---

# Introduction de PersistentVolumes et PersistentVolumeClaims

- Au lieu que le développeur ajoute un volume spécifique à son pod, c'est l'administrateur du cluster qui configure le stockage sous-jacent, puis l'enregistre dans
Kubernetes en créant une ressource PersistentVolume via le serveur de l'API Kubernetes.

- Lors de la création de PersistentVolume, l'administrateur spécifie sa taille et les modes d'accès
qu'il supporte.

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Introduction de PersistentVolumes et PersistentVolumeClaims

- Lorsqu'un utilisateur de cluster doit utiliser un stockage persistant dans l'un de ses pods, il crée d'abord un manifeste PersistentVolumeClaim, en spécifiant la taille minimale et le mode d'accès qu'ils exigent.

- L'utilisateur soumet ensuite le manifeste PersistentVolumeClaim au serveur de l'API Kubernetes, et Kubernetes trouve le PersistentVolume approprié et lie au Volume Claim.

- Le PersistentVolumeClaim peut alors être utilisé comme l'un des volumes à l'intérieur d'un pod. Les autres utilisateurs ne peuvent pas utiliser le même PersistentVolume jusqu'à ce qu'il ait été libéré en supprimant
le PersistentVolumeClaim lié.

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Exemple de PersistentVolumes et PersistentVolumeClaims

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

class: pic

![haha seulement blague](images/volumes3.png)

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## PersistentVolumes et Namespaces

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

class: pic

![haha seulement blague](images/Volume4.png)

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Durée de vie de PersistentVolume et PersistentVolumeClaims

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

class: pic

![haha seulement blague](images/Volume5.png)

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

class: pic

.interstitial[![Image separating from the next chapter](https://gallant-turing-d0d520.netlify.com/containers/blue-containers.jpg)]

---

name: toc-provisionnement-dynamique-des-volumes-persistants
class: title

Provisionnement dynamique des volumes persistants

.nav[
[Section précédente](#toc-introduction-de-persistentvolumes-et-persistentvolumeclaims)
|
[Retour table des matières](#toc-chapter-2)
|
[Section suivante](#toc-rook-orchestration-de-stockage-distribu)
]

.debug[(automatically generated title slide)]

---
# Provisionnement dynamique des volumes persistants

- Les schemas précédents ont été repris du livre de Marko Luksa "Kubernetes in Action"

- Nous avons vu comment l'utilisation de PersistentVolumes et PersistentVolumeClaims facilite l'obtention d'un stockage persistant sans que le développeur n'ait à gérer le stockage réel utilisée en dessous.

- Mais cela nécessite toujours un administrateur de cluster pour provisionner le stockage réel à l'avance.

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Provisionnement dynamique des volumes persistants

- Heureusement, Kubernetes peut également effectuer ce travail automatiquement grâce au provisionnement dynamique de PersistentVolumes.

- L'administrateur du cluster, au lieu de créer PersistentVolumes, peut déployer un provisionneur PersistentVolume et définir un ou plusieurs objets StorageClass pour permettre aux utilisateurs de choisir le type de PersistentVolume souhaité.

- Les utilisateurs peuvent se référer à StorageClass dans leur PersistanceVolumeClaims et le provisionneur en tiendra compte lors de l'approvisionnement du stockage persistant.

- Le schema suivant a été repris du livre de Marko Luksa "Kubernetes in Action" 

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Provisionnement dynamique des volumes persistants

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

class: pic

![haha seulement blague](images/volume6.png)

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

class: pic

.interstitial[![Image separating from the next chapter](https://gallant-turing-d0d520.netlify.com/containers/chinook-helicopter-container.jpg)]

---

name: toc-rook-orchestration-de-stockage-distribu
class: title

Rook orchestration de stockage distribué

.nav[
[Section précédente](#toc-provisionnement-dynamique-des-volumes-persistants)
|
[Retour table des matières](#toc-chapter-2)
|
[Section suivante](#toc-exercice-ab-testing-la-suite)
]

.debug[(automatically generated title slide)]

---

# Rook orchestration de stockage distribué

- Rook est un orchestrateur open source pour les systèmes de stockage distribués.

- Rook transforme le logiciel de stockage distribué en un service de stockage auto-géré, auto-scalable et auto-guérisant.

- Il le fait en automatisant le déploiement, l'amorçage, la configuration, l'approvisionnement, la mise à l'échelle, la mise à niveau, la migration, la reprise après sinistre, la surveillance et la gestion des ressources.

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Rook orchestration de stockage distribué

- Rook se concentre d'abord sur l'orchestration de Ceph sur Kubernetes. Ceph est un système de stockage distribué qui permet le stockage de fichiers, de blocs et d'objets et qui est déployé dans des clusters de production à grande échelle.

- Rook est hébergé par la Cloud Native Computing Foundation (CNCF) en tant que projet de niveau initial.

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Exemple de provisionnement dynamique de PersistentVolumes à l'aide de Rook

.exercise[
  ```bash
   git clone https://github.com/rook/rook.git
   cd rook/cluster/examples/kubernetes/ceph
   kubectl create -f operator.yaml
   kubectl create -f cluster.yaml
  ```
- vérifiez pour voir si tout fonctionne comme prévu
  ```bash
   kubectl get pods -n rook-ceph
  ```

]

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Exemple de provisionnement dynamique de PersistentVolumes à l'aide de Rook

- Le stockage 'block' vous permet de monter le stockage dans un seul pod.

- Voyons comment construire une application web simple et multi-niveaux sur Kubernetes en utilisant des volumes persistants activés par Rook.

--

- Avant que Rook puisse démarrer le provisionnement, une classe StorageClass et son pool de stockage doivent être créés.

- Ceci est nécessaire pour que Kubernetes puisse interopérer avec Rook pour provisionner des volumes persistants.

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---
## Exemple de provisionnement dynamique de PersistentVolumes à l'aide de Rook

<!--   kubectl create -f pool.yaml -->
.exercise[
- Créez le pool et le storage class:
  ```bash
  kubectl create -f storageclass.yaml
  ```
]
- Consommez le stockage avec l'échantillon wordpress
- Nous créons un exemple d'application pour consommer le stockage en 'block' provisionné par Rook avec les applications classiques wordpress et mysql.
- Ces deux applications utiliseront les volumes 'block' provisionnés par Rook.

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Exemple de provisionnement dynamique de PersistentVolumes à l'aide de Rook


.exercise[
- Démarrez mysql et wordpress depuis le dossier cluster/examples/kubernetes:
  ```bash
  kubectl create -f mysql.yaml
  kubectl create -f wordpress.yaml
  ```
- Ces deux applications créent un volume en 'block' et le montent dans leur pod respectif. Vous pouvez voir les 'volume claims' de Kubernetes en exécutant les opérations suivantes:

  ```bash
  kubectl get pvc
  ```
- Vous devriez voir quelque chose comme ça:
```bash
NAME             STATUS    VOLUME        CAPACITY   ACCESSMODES   AGE
mysql-pv-claim   Bound     pvc-954459ee   20Gi       RWO           1m
wp-pv-claim      Bound     pvc-39e459ee   20Gi       RWO           1m
```
]
.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Exemple de provisionnement dynamique de PersistentVolumes à l'aide de Rook

.exercise[
- Une fois que les pods wordpress et mysql sont dans l'état Running, récupérez l'adresse IP du cluster de l'application wordpress et entrez-la dans votre navigateur avec le port:

 ```bash
 kubectl get svc wordpress
 ```
]
Vous devriez voir l'application wordpress en cours d'exécution.

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Lancez un autre exemple de provisionnement dynamique

.exercise[

- Récupérez le fichier:
  ```bash
  wget https://raw.githubusercontent.com/zonca/jupyterhub-deploy-kubernetes-jetstream/master/storage_rook/alpine-rook.yaml
  ```

- Modifiez-le pour qu'il corresponde aux spécifications de votre cluster (notre `storageClassName` est `"rook-ceph-block"`) et exécutez-le en utilisant:
  ```bash
  kubectl create -f alpine-rook.yaml
  ```

]

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Lancez un autre exemple de provisionnement dynamique (suite)

- C'est un petit pod avec Alpine Linux qui crée un volume de 2 Go à partir de Rook et le monte sur /data.

- Cela crée un Pod avec Alpine Linux qui demande qu'un Persistent Volume Claim soit montée sous /data.

- Le PersistentVolumeClaim spécifiait le type de stockage et sa taille.

- Une fois le Pod créé, il demande au PersistentVolumeClaim de demander à Rook de préparer un volume persistant qui sera ensuite monté dans le pod.

.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

## Lancez un autre exemple de provisionnement dynamique (suite)

- Nous pouvons vérifier que les Volumes Persistants sont créés et associés au pod, vérifiez:

.exercise[
  ```bash
  kubectl get pv
  kubectl get pvc
  kubectl logs alpine
  ```
- Obtenez un shell dans le pod avec:
  ```bash
  kubectl exec -it alpine /bin/sh
  ```
- Créer des fichiers dans `/data/`.
- Quitter le terminal
- Maintenant supprimez le pod. Est-il encore possible daccéder ces données ? Si oui, comment ?
]

<!-----
## Lancez un autre exemple de provisionnement dynamique (suite)

.exercise[
- Comment aurions-nous pu récupérer les données dans le dernier cas?
- Changeons alpine-rook.yaml en `kind:deployment`, écrivez quelques fichiers et tuez à nouveau le pod pour voir ce qui se passe.
]-->



.debug[[kube/stockage_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/stockage_fr.md)]
---

class: pic

.interstitial[![Image separating from the next chapter](https://gallant-turing-d0d520.netlify.com/containers/container-cranes.jpg)]

---

name: toc-exercice-ab-testing-la-suite
class: title

Exercice A/B testing, la suite

.nav[
[Section précédente](#toc-rook-orchestration-de-stockage-distribu)
|
[Retour table des matières](#toc-chapter-3)
|
[Section suivante](#toc-dcouplage-de-configuration-avec-un-configmap)
]

.debug[(automatically generated title slide)]

---

# Exercice A/B testing, la suite

L'équipe marketing à determiner que la vA du serveurweb était la meilleure.

Vous aller donc lancer un service qui exposera un **pod**.

Cependant, ils veulent aussi que vous rajoutiez un dossier `bonus` dans /tmp/ qui contiendra un fichier `bonus.txt`. Ce fichier aura juste le texte "bonus" dedans.

Lors de la réunion vous sentez que ce fichier va surement changer souvent... Vous décidez qu'au lieu de changer l'image docker, vous aller monter un volume persitant qui vous permettera de changer rapidement le contenu de ce dossier.

- Conseil: ne foncez pas tête baisser. Faites un plan, puis éxecutez le.

- Conseil 2: la slide suivante contient de l'aide... A vous de voir...

.debug[[kube/exo-ab-testing/exo2.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/exo-ab-testing/exo2.md)]
---

## Aide

- Repartez de https://raw.githubusercontent.com/zonca/jupyterhub-deploy-kubernetes-jetstream/master/storage_rook/alpine-rook.yaml

- l'image du serveur A s'appelle `127.0.0.1:32092/serverweb:vA`

- Pour écrire le fichier bonus, connéctez-vous au pod:
  ```bash
kubectl exec -ti alpine -- sh
  ```




.debug[[kube/exo-ab-testing/exo2.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/exo-ab-testing/exo2.md)]
---

class: pic

.interstitial[![Image separating from the next chapter](https://gallant-turing-d0d520.netlify.com/containers/container-housing.jpg)]

---

name: toc-dcouplage-de-configuration-avec-un-configmap
class: title

Découplage de configuration avec un ConfigMap

.nav[
[Section précédente](#toc-exercice-ab-testing-la-suite)
|
[Retour table des matières](#toc-chapter-4)
|
[Section suivante](#toc-introduction-des-secrets)
]

.debug[(automatically generated title slide)]

---
# Découplage de configuration avec un ConfigMap

- Le but de la configuration d'une application est de garder les options de configuration qui varient d'un environnement à l'autre, ou de changer fréquemment, séparément de la source de l'application
code.

- Si vous considérez un descripteur de pod comme un code source pour votre application (il définit comment composer les composants individuels dans un système fonctionnel), il est clair que vous devez supprimer la configuration de la description du pod.

.debug[[kube/configs_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/configs_fr.md)]
---

## Introduction de ConfigMap

- Kubernetes permet de séparer les options de configuration en un objet distinct appelé ConfigMap, qui est une map contenant des paires clé / valeur avec des valeurs allant de
des littéraux courts aux fichiers de configuration complets.

- Une application n'a pas besoin de lire directement le ConfigMap ou même de savoir qu'il existe. Le contenu de la map est plutôt transmis aux conteneurs comme environnement
variables ou en tant que fichiers dans un volume.

.debug[[kube/configs_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/configs_fr.md)]
---

## Introduction de ConfigMap

- Vous pouvez définir les entrées de la map en transmettant des littéraux à la commande kubectl ou vous pouvez créer ConfigMap à partir de fichiers stockés sur votre disque.

.exercise[
- Pour créer une nouvelle entrée:
  ```bash
  kubectl create configmap fortune-config --from-literal=sleep-interval=25
  ```
- Pour regarder les valeurs d'un ConfigMap:
  ```bash
  kubectl describe configmap fortune-config
  ```
]

- REMARQUE Les clés ConfigMap doivent être un sous-domaine DNS valide (elles ne peuvent contenir que des caractères alphanumériques, des tirets, des traits de soulignement et des points). Ils peuvent éventuellement commencer par un point.

.debug[[kube/configs_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/configs_fr.md)]
---

## Explication de Configmaps dans un exemple

- Exécutez l'exemple décrit ici: https://kubernetes.io/docs/tutorials/configuration/configure-redis-using-configmap/

Attention ! Votre version de Kubernetes ne supporte pas encore qu'il est une URL dans l'option --from-file !


- Pour aller plus loin: https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/

.debug[[kube/configs_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/configs_fr.md)]
---

class: pic

.interstitial[![Image separating from the next chapter](https://gallant-turing-d0d520.netlify.com/containers/containers-by-the-water.jpg)]

---

name: toc-introduction-des-secrets
class: title

Introduction des secrets

.nav[
[Section précédente](#toc-dcouplage-de-configuration-avec-un-configmap)
|
[Retour table des matières](#toc-chapter-4)
|
[Section suivante](#toc-monitoring-avec-prometheus-et-grafana)
]

.debug[(automatically generated title slide)]

---

# Introduction des secrets

- Kubernetes fournit un objet séparé appelé Secret. Les secrets ressemblent beaucoup à ConfigMaps

- Ce sont aussi des maps qui contiennent des paires clé-valeur. Ils peuvent être utilisés de la même manière qu'un ConfigMap.

- Vous pouvez passer des entrées secrètes au conteneur en tant que variables d'environnement

- Expose les entrées secrètes en tant que fichiers dans un volume

.debug[[kube/configs_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/configs_fr.md)]
---

## Introduction des secrets

- Kubernetes aide à garder vos secrets en toute sécurité en s'assurant que chaque secret est seulement distribué
aux nœuds qui exécutent les pods qui ont besoin d'accéder au secret.

- De plus, sur les nœuds eux-mêmes, les Secrets sont toujours stockés en mémoire et jamais écrits dans le stockage physique,
ce qui nécessiterait de nettoyer les disques après avoir supprimé les secrets d'eux.

.debug[[kube/configs_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/configs_fr.md)]
---
## Introduction des secrets

- Sur le nœud maître proprement dit, etcd stocke les secrets sous forme cryptée, ce qui rend le système beaucoup plus sécurisé. Pour cette raison, il est impératif que vous choisissez correctement quand utiliser un Secret ou un ConfigMap. Choisir entre eux est simple:

 * Utilisez un fichier ConfigMap pour stocker des données de configuration non sensibles et simples.
--

 * Utilisez un secret pour stocker toutes les données sensibles et doivent être conservées sous clé. Si un fichier de configuration contient des données sensibles mais aussi non sensibles, vous
devrez stocker le fichier dans un secret.

.debug[[kube/configs_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/configs_fr.md)]
---

## Exercices utilisant des secrets

- Quelques exercices initiaux utilisant Secrets peuvent être trouvés ici: https://kubernetes.io/docs/concepts/configuration/secret/

.debug[[kube/configs_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/configs_fr.md)]
---

class: pic

.interstitial[![Image separating from the next chapter](https://gallant-turing-d0d520.netlify.com/containers/distillery-containers.jpg)]

---

name: toc-monitoring-avec-prometheus-et-grafana
class: title

Monitoring avec Prometheus et Grafana

.nav[
[Section précédente](#toc-introduction-des-secrets)
|
[Retour table des matières](#toc-chapter-5)
|
[Section suivante](#toc-statefulsets)
]

.debug[(automatically generated title slide)]

---
# Monitoring avec Prometheus et Grafana

- Prometheus, pour le monitoring

- Grafana, pour afficher les métriques et jouer avec.

.debug[[kube/monitoring_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/monitoring_fr.md)]
---

## Kube Prometheus

Kube Prometheus est un dépot git qui permet d'installer une stack de monitoring Prometheus+Grafana pour kubernetes.
Il configure aussi Grafana pour intégrer des graphiques utiles.

.exercise[
  ```bash
git clone https://github.com/coreos/prometheus-operator.git

cd prometheus-operator/contrib/kube-prometheus/

kubectl create -f manifests/
  ```
]

.debug[[kube/monitoring_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/monitoring_fr.md)]
---

## Grafana

.exercise[
- Ouvrez le service grafana à l'exterieur, connectez-vous y avec votre navigateur web

- Si vous avez besoin  de vous logguer : admin/admin

- Cliquez sur "Home" tout en haut de l'écran, choisissez le dashboard *Pods*.

- Quel est l'utilisation mémoire du pod registery ?

- Quel est le coût des pods du daemonset de prometheus ?

]


.debug[[kube/monitoring_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/monitoring_fr.md)]
---

## reset

  ```bash
kubectl delete -f manifests/
  ```


.debug[[kube/monitoring_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/monitoring_fr.md)]
---

class: pic

.interstitial[![Image separating from the next chapter](https://gallant-turing-d0d520.netlify.com/containers/lots-of-containers.jpg)]

---

name: toc-statefulsets
class: title

StatefulSets

.nav[
[Section précédente](#toc-monitoring-avec-prometheus-et-grafana)
|
[Retour table des matières](#toc-chapter-6)
|
[Section suivante](#toc-tp-wordpress)
]

.debug[(automatically generated title slide)]

---

# StatefulSets

- A StatefulSet allows to have a group of pods that have a stable name and state.

- What is the difference with ReplicaSet (deployment) ?

  - A ReplicaSet is like managing a cattle of cows : we do not care about the names of cows, we just want to know how many we have. If a cow is ill we replace her.

  - A StatefulSet is like managing a group of domestic animals : we give them names and we cannot replace them easily. If we have to replace one we need to find one with the same name and the same appearance.


.debug[[kube/statefulsets.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/statefulsets.md)]
---
## Replicate Stateful pods


![replicasets](images/replicasets.png)

Because of the ReplicaSet template system, we can only give one and only name for the PersistentVolumeClaim.

For a ReplicaSet, all replicas use the same PersistentVolumeClaim !

.debug[[kube/statefulsets.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/statefulsets.md)]
---

## The StatefulSets allow us to have unique names 


![replicasets](images/replicasets_statefulsets.png)

What happens if a node dies ?

.debug[[kube/statefulsets.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/statefulsets.md)]
---

class: pic

![replicasets](images/statefulset_nodefail.png)

.debug[[kube/statefulsets.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/statefulsets.md)]
---

## Statefulset, change of the replicas number

![replicasets](images/statefulset_scaledown.png)

The pod with the higher ID is destroyed first!

What happens with the attached PVC?

.debug[[kube/statefulsets.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/statefulsets.md)]
---

class: pic


![replicasets](images/statefulsetPVC_scaledown.png)


.debug[[kube/statefulsets.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/statefulsets.md)]
---
## Statefulset exercises

- The schemas have been taken from the book of Marko Luksa "Kubernetes in Action"

.exercise[

- *mehdb* is database (*meh* in anglais).
It replicates automatically the data between each instance.

  ```bash
wget https://gist.githubusercontent.com/glesserd/a0db0439e69426d92c632fb5c9bcba1c/raw/56b05fcdf9d4d1bbdf5f5cdca3fc104d7dca7d24/app.yaml
  ```

- Let's check the YAML...

]

Attention ! This application does not work... Indeed the data are not replicated. But it is not important for our tests with Kubernetes.


.debug[[kube/statefulsets.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/statefulsets.md)]
---
## Deployment
.exercise[
- Deploy it

  ```bash
kubectl get statefulset
kubectl get sts
  ```

- We scale the bdd

  ```bash
kubectl scale sts mehdb --replicas=4
  ```

- How did everything go ?
  ```bash
kubectl get sts
kubectl get pvc
  ```

]

.debug[[kube/statefulsets.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/statefulsets.md)]
---
## Resistance to crashes

.exercise[
- Let's kill a pod!

  ```bash
kubectl delete pod mehdb-1
  ```

- Which pod is going to be re-created ?

  ```bash
kubectl get pod
  ```

]

.debug[[kube/statefulsets.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/statefulsets.md)]
---
## Scale down

.exercise[
- Let's scale down:
  ```bash
kubectl scale sts mehdb --replicas=2
  ```


- Did everything go well ?
  ```bash
kubectl get sts
kubectl get pvc
  ```

- The PVC are still there as expected !

]

.debug[[kube/statefulsets.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/statefulsets.md)]
---
## Reset

.exercise[
- Reset:

  ```bash
kubectl delete -f app.yaml
  ```

* Do not forget to delete the PVC !!!*

]



.debug[[kube/statefulsets.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/statefulsets.md)]
---

class: pic

.interstitial[![Image separating from the next chapter](https://gallant-turing-d0d520.netlify.com/containers/plastic-containers.JPG)]

---

name: toc-tp-wordpress
class: title

TP Wordpress

.nav[
[Section précédente](#toc-statefulsets)
|
[Retour table des matières](#toc-chapter-7)
|
[Section suivante](#toc-cest-parti-)
]

.debug[(automatically generated title slide)]

---
# TP Wordpress

Wordpress est un moteur de site web écrit en PHP. Il est utilisé par plus de 60 millions de sites webs dans le monde.

Nous allons déployer une instance wordpress sur notre cluster.

Wordpress necessite une base de donnée pour fonctionner (généralement MySQL).

Mais aussi d'un dossier de cache.

Et un dossier permettant de stocker les fichiers uploadés (images ou documents pour le site).


.debug[[kube/exo-wordpress/tp_wordpress.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/exo-wordpress/tp_wordpress.md)]
---

## Question 1

.exercise[

De quels "objets" Kubernetes avons-nous besoin ?

**(Solution sur la slide suivante)**

]


.debug[[kube/exo-wordpress/tp_wordpress.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/exo-wordpress/tp_wordpress.md)]
---

## Question 1

.exercise[

De quels "objets" Kubernetes avons-nous besoin ?

]

- 2 pods : 1 pour Kubernetes, 1 pour Mysql

- 2 deployments : pour gérer les pods

- 1 service "ClusterIP" mysql, pour n'éxposer la BdD en interne uniquement

- 1 service "NodePort" (ou "LoadBalancer") wordpress, pour exposer le service au monde exterieur

- 3 persistentVolume pour stocker les données.

- 1 secret pour partager entre les pods le mot de passe d'accès à MySQL.

.debug[[kube/exo-wordpress/tp_wordpress.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/exo-wordpress/tp_wordpress.md)]
---

class: pic

.interstitial[![Image separating from the next chapter](https://gallant-turing-d0d520.netlify.com/containers/train-of-containers-1.jpg)]

---

name: toc-cest-parti-
class: title

C'est parti !

.nav[
[Section précédente](#toc-tp-wordpress)
|
[Retour table des matières](#toc-chapter-7)
|
[Section suivante](#toc-autoscaling-avec-kubernetes)
]

.debug[(automatically generated title slide)]

---
# C'est parti !

.exercise[
Créez les YAMLs nécessaire (ou non) pour chaque objet.

**(Sur les prochaines slides sont détaillées chaque objet avec un bout de solution)**
**(Puis, la solution est donnée tout à la fin)**

]



.debug[[kube/exo-wordpress/tp_wordpress.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/exo-wordpress/tp_wordpress.md)]
---
## persistentVolume

Sur le cluster est installé rook.
Rook est un fournisseur de persistentVolume basé sur Ceph.

Il nous suffira de créer des PersistentVolumeClaim avec comme classe "rook-ceph-block" pour obtenir dynamiquent de nouveaux volumes.

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pv-claim
  labels:
    app: wordpress
spec:
  storageClassName: rook-ceph-block
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi
```

.debug[[kube/exo-wordpress/tp_wordpress.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/exo-wordpress/tp_wordpress.md)]
---
## persistentVolume

Et pour utiliser ce PersistentVolumeClaim, on ajoutera un volume au pod, et on montera ce volume dans le bon dossier:


```yaml
    ...
    spec:
      containers:
        ...
        volumeMounts:
        - name: mysql-persistent-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-persistent-storage
        persistentVolumeClaim:
          claimName: mysql-pv-claim
```

.debug[[kube/exo-wordpress/tp_wordpress.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/exo-wordpress/tp_wordpress.md)]
---
## Secrets

.exercise[
- Créer, depuis la ligne de commande, un secret contenant le mot de passe MySQL.
```bash
kubectl create secret generic mysql-pass --from-literal=password=superpassword```

]

On pourra ensutie utiliser cette valeure au moment de définir les variables d'environement de l'image:

```yaml
env:
- name: MYSQL_ROOT_PASSWORD
    valueFrom:
    secretKeyRef:
        name: mysql-pass
        key: password
```

.debug[[kube/exo-wordpress/tp_wordpress.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/exo-wordpress/tp_wordpress.md)]
---
## Deployments

Nous utiliserons des deployments pour gérer nos pods.

```yaml
apiVersion: apps/v1beta1
kind: Deployment
metadata:
  name: wordpress-mysql
  labels:
    app: wordpress
spec:
  template:
    metadata:
      labels:
        app: wordpress
        tier: mysql
    spec:
      containers:
      - image: mysql:5.6
        name: mysql
      ...
```

.debug[[kube/exo-wordpress/tp_wordpress.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/exo-wordpress/tp_wordpress.md)]
---
## Service

Enfin nous auront des services pour éxposer en interne ou externe les déployments wordpress et mysql.

Exemple:

```yaml
apiVersion: v1
kind: Service
metadata:
  name: wordpress-mysql
  labels:
    app: wordpress
spec:
  ports:
    - port: 3306
  selector:
    app: wordpress
    tier: mysql
  clusterIP: None
```

.debug[[kube/exo-wordpress/tp_wordpress.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/exo-wordpress/tp_wordpress.md)]
---
## Let's go!

.exercise[
Récupérer les yamls et déployez-les!

```bash
wget https://gist.githubusercontent.com/glesserd/24310a37f464d6d7569c358bcec3213d/raw/f3d0ad463659b002d2d7a047ccae9dea7fe6a60f/mysql.yaml

wget https://gist.githubusercontent.com/glesserd/e89d765ee9cfa99bd274350c3fbdb12b/raw/66e26359f5b81d7be3b58f043500428db7fe78ea/wordpress.yaml

kubectl apply -f mysql.yaml
kubectl apply -f wordpress.yaml

```

]









.debug[[kube/exo-wordpress/tp_wordpress.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/exo-wordpress/tp_wordpress.md)]
---

class: pic

.interstitial[![Image separating from the next chapter](https://gallant-turing-d0d520.netlify.com/containers/train-of-containers-2.jpg)]

---

name: toc-autoscaling-avec-kubernetes
class: title

Autoscaling avec Kubernetes

.nav[
[Section précédente](#toc-cest-parti-)
|
[Retour table des matières](#toc-chapter-8)
|
[Section suivante](#toc-cicd-with-spinnaker)
]

.debug[(automatically generated title slide)]

---
# Autoscaling avec Kubernetes

Nous allons mettre en place un système d'autoscaling basé sur k8s-prom-hpa. Ce logicil à l'avantage d'être simple, fonctionel et extensible grâce à Prometheus.

.exercise[
- Récupérez le logiciel:

  ```bash
git clone https://github.com/stefanprodan/k8s-prom-hpa.git
cd k8s-prom-hpa/
  ```

]

.debug[[kube/advanced_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/advanced_fr.md)]
---

## Récupérez les métriques

Déployons le *Metrics Server*, le server qui va récupérez les métriques sur les noeuds et les transmettre en utilisant l'API standard de kubernetes:

.exercise[
  ```bash
kubectl create -f ./metrics-server
  ```
]

(Avant k8s 1.8, Heapster permettait de faire cela. Ce projet a été fusionner avec Kubernetes pour faire *Metrics Server*.)

.debug[[kube/advanced_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/advanced_fr.md)]
---

## HorizontalPodAutoscaler CRD

.exercise[
La prochaine commande définit un nouveau type d'objet (un Custorm Resource Definition (CRD)), et lance le controlleur de ce CRD.

On peut donc maintenant intéragir avec le type HorizontalPodAutoscaler comme tout les autres objets de kubernetes:

  ```bash
kubectl get hpa
  ```

]

.debug[[kube/advanced_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/advanced_fr.md)]
---

## Déploiement d'une application

.exercise[
On deploie maintenant une application affichant sur une interface web des informations décrivant son pod:

  ```bash
kubectl create -f ./podinfo/podinfo-svc.yaml,./podinfo/podinfo-dep.yaml
  ```

Vous pouvez regarder ce que ces infos sont:
  ```bash
curl IP_PUBLIC:PORT_DU_SERVICE
  ```
]

.debug[[kube/advanced_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/advanced_fr.md)]
---

## Mise en place des règles d'auto-scaling

.exercise[
On va maintenant créer les règles HorizontalPodAutoscaler:

  ```bash
kubectl create -f ./podinfo/podinfo-hpa.yaml
  ```

Regardez ce yaml pour voir ce que définissent ces règles !

On a donc maintenant une nouvelle hpa:
  ```bash
kubectl get hpa
  ```
]

.debug[[kube/advanced_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/advanced_fr.md)]
---

## Stress de l'application

.exercise[
On va maintenant strésser le service pour que le scaling ce lance, dans un nouveau terminal :
  ```bash
cd ~/
mkdir golang
export GOPATH=~/golang/
export GOROOT=/usr/lib/go-1.10
export PATH=$GOPATH/bin:$GOROOT/bin:$PATH
go get -u github.com/rakyll/hey
hey -n 10000 -q 10 -c 5 http://IP_PUBLIC:PORT_DU_SERVICE/
  ```

]
.debug[[kube/advanced_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/advanced_fr.md)]
---

## Stress de l'application 2

.exercise[

Observez ce qui se passe pour le hpa:
  ```bash
kubectl describe hpa
  ```

]

L'autoscaler ne réagit pas immédiatement au pics d'utilisation.
Par défaut, les métriques sont synchronisées toutes les 30s.
De plus, le scaling up/down peut seulement avoir lieu si il n'y pas déjà eu un scaling dans les 5 minutes.
Cela permet au HPA de prendre des décisions trop rapides et/ou contradictoires.

.debug[[kube/advanced_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/advanced_fr.md)]
---

## En savoir plus

- The procedure is explained in detail and with more examples here: https://www.weave.works/blog/kubernetes-horizontal-pod-autoscaler-and-prometheus

- Pour reset:
  ```bash
kubectl delete -f ./podinfo/podinfo-hpa.yaml
kubectl delete -f ./podinfo/podinfo-svc.yaml,./podinfo/podinfo-dep.yaml
kubectl delete -f ./metrics-server
  ```







.debug[[kube/advanced_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/advanced_fr.md)]
---
---

class: pic

.interstitial[![Image separating from the next chapter](https://gallant-turing-d0d520.netlify.com/containers/two-containers-on-a-truck.jpg)]

---

name: toc-cicd-with-spinnaker
class: title

CI/CD with Spinnaker

.nav[
[Section précédente](#toc-autoscaling-avec-kubernetes)
|
[Retour table des matières](#toc-chapter-8)
|
[Section suivante](#toc-dploiement-de-jupiter-sur-kubernetes)
]

.debug[(automatically generated title slide)]

---

# CI/CD with Spinnaker

.exercise[
- We will perform the exercise from the following link:
  https://thenewstack.io/getting-started-spinnaker-kubernetes/

 * However, since we already have our own cluster and Helm installed, we will start the tutorial from the "Installing Spinnaker" section

]


.debug[[kube/advanced_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/advanced_fr.md)]
---
---

class: pic

.interstitial[![Image separating from the next chapter](https://gallant-turing-d0d520.netlify.com/containers/wall-of-containers.jpeg)]

---

name: toc-dploiement-de-jupiter-sur-kubernetes
class: title

Déploiement de Jupiter sur Kubernetes

.nav[
[Section précédente](#toc-cicd-with-spinnaker)
|
[Retour table des matières](#toc-chapter-8)
|
[Section suivante](#toc-scheduling-avance-avec-kubernetes)
]

.debug[(automatically generated title slide)]

---

# Déploiement de Jupiter sur Kubernetes

.exercise[
- Nous suivrons la procédure fournie ici : 
  https://zonca.github.io/2017/12/scalable-jupyterhub-kubernetes-jetstream.html

]

.debug[[kube/advanced_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/advanced_fr.md)]
---

class: pic

.interstitial[![Image separating from the next chapter](https://gallant-turing-d0d520.netlify.com/containers/Container-Ship-Freighter-Navigation-Elbe-Romance-1782991.jpg)]

---

name: toc-scheduling-avance-avec-kubernetes
class: title

Scheduling avancée avec Kubernetes

.nav[
[Section précédente](#toc-dploiement-de-jupiter-sur-kubernetes)
|
[Retour table des matières](#toc-chapter-8)
|
[Section suivante](#toc-big-data-analytics-sur-kubernetes)
]

.debug[(automatically generated title slide)]

---
--- 

# Scheduling avancée avec Kubernetes

.exercise[
- Nous suivrons la procédure fournie ici : 
   https://github.com/RyaxTech/kube-tutorial#4-activate-an-advanced-scheduling-policy-and-test-its-usage
]

.debug[[kube/advanced_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/advanced_fr.md)]
---
---

class: pic

.interstitial[![Image separating from the next chapter](https://gallant-turing-d0d520.netlify.com/containers/ShippingContainerSFBay.jpg)]

---

name: toc-big-data-analytics-sur-kubernetes
class: title

Big Data analytics sur Kubernetes

.nav[
[Section précédente](#toc-scheduling-avance-avec-kubernetes)
|
[Retour table des matières](#toc-chapter-8)
|
[Section suivante](#toc-)
]

.debug[(automatically generated title slide)]

---

# Big Data analytics sur Kubernetes

.exercise[
- Nous suivrons la procédure fournie ici :
https://github.com/RyaxTech/kube-tutorial#3-execute-big-data-job-with-spark-on-the-kubernetes-cluster
]



.debug[[kube/advanced_fr.md](https://github.com/RyaxTech/kube.training.git/tree/gh-pages//kube/advanced_fr.md)]</textarea>
    <script src="remark.min.js" type="text/javascript">
    </script>
    <script src="viz.js"></script>
    <script type="text/javascript">
      var slideshow = remark.create({
        ratio: '16:9',
        highlightSpans: true,
        excludedClasses: ["self-paced"]
      });

    var viz = new Viz({ workerURL: './lite.render.js' });
    var currentSlideViz = document.querySelectorAll(".vizgraph");
    currentSlideViz.forEach((elm) => {
        viz.renderSVGElement(elm.innerText)
        .then(function(element) {
            //the new svg element inherit class of the old element
            elm.classList.forEach((l) => { element.classList.add(l)});
            elm.replaceWith(element);
        });
    });

    </script>
    <!-- 
    These two scripts will be available only when loading the
    content using the pub/sub server. Otherwise, they'll just
    404 and that's OK.
    -->
    <script src="/socket.io/socket.io.js">
    </script>
    <script src="/remote.js">
    </script>

  </body>
</html>
